#!/usr/bin/env python3
"""
Java Be Good - Technical Coding Edition
A hands-on game to practice Java programming through actual code writing
Inspired by ThePrimeagen's vim-be-good but focused on deep Java mastery
"""

import random
import time
import os
import sys
import re
from typing import List, Dict, Any, Callable, Optional
from dataclasses import dataclass
from enum import Enum

class Difficulty(Enum):
    NOOB = "noob"
    EASY = "easy" 
    MEDIUM = "medium"
    HARD = "hard"
    NIGHTMARE = "nightmare"

@dataclass
class GameResult:
    correct: bool
    time_taken: float
    attempts: int
    hints_used: int

class JavaBeGood:
    def __init__(self):
        self.score = 0
        self.total_games = 0
        self.difficulty = Difficulty.EASY
        self.hints_used_total = 0
        
    def clear_screen(self):
        """Clear the terminal screen"""
        os.system('cls' if os.name == 'nt' else 'clear')
    
    def print_banner(self):
        """Print the game banner"""
        banner = """
╔═══════════════════════════════════════╗
║         JAVA BE GOOD - TECH           ║
║       Write Real Code, Master         ║
║       Object-Oriented Programming     ║
╚═══════════════════════════════════════╝
        """
        print(banner)
        print(f"Score: {self.score} | Games: {self.total_games} | Hints Used: {self.hints_used_total} | Difficulty: {self.difficulty.value}")
        print("-" * 45)
    
    def show_menu(self) -> str:
        """Show main menu and get user choice"""
        options = {
            "1": "Class Implementation Challenges",
            "2": "Collection Operations & Data Structures", 
            "3": "Exception Handling & Error Management",
            "4": "Inheritance & Polymorphism Deep Dive",
            "5": "Interface & Abstract Class Architecture",
            "6": "Generic Programming & Type Safety",
            "7": "Lambda & Stream API Mastery",
            "8": "Design Pattern Implementation",
            "9": "Algorithm & Logic Challenges",
            "10": "Bug Hunt & Code Refactoring",
            "11": "Advanced Java Features",
            "12": "Change Difficulty",
            "13": "View Stats",
            "q": "Quit"
        }
        
        print("\nChoose your coding challenge:")
        for key, value in options.items():
            print(f"{key:2}. {value}")
        
        while True:
            choice = input("\nEnter your choice: ").strip().lower()
            if choice in options:
                return choice
            print("Invalid choice! Please try again.")
    
    def set_difficulty(self):
        """Allow user to change difficulty"""
        print("\nSelect difficulty:")
        descriptions = {
            Difficulty.NOOB: "Basic syntax and simple implementations",
            Difficulty.EASY: "Standard OOP concepts with guidance", 
            Difficulty.MEDIUM: "Complex scenarios requiring deeper understanding",
            Difficulty.HARD: "Advanced patterns and optimization challenges",
            Difficulty.NIGHTMARE: "Expert-level architecture and performance"
        }
        
        for i, diff in enumerate(Difficulty, 1):
            print(f"{i}. {diff.value.title()}: {descriptions[diff]}")
        
        try:
            choice = int(input("Enter choice (1-5): "))
            if 1 <= choice <= 5:
                self.difficulty = list(Difficulty)[choice - 1]
                print(f"Difficulty set to: {self.difficulty.value}")
            else:
                print("Invalid choice!")
        except ValueError:
            print("Invalid input!")
        
        input("Press Enter to continue...")
    
    def get_time_limit(self) -> float:
        """Get time limit based on difficulty"""
        limits = {
            Difficulty.NOOB: 300.0,    # 5 minutes
            Difficulty.EASY: 240.0,    # 4 minutes
            Difficulty.MEDIUM: 180.0,  # 3 minutes
            Difficulty.HARD: 120.0,    # 2 minutes
            Difficulty.NIGHTMARE: 90.0 # 1.5 minutes
        }
        return limits[self.difficulty]
    
    def show_hint(self, hints: List[str], hints_used: int) -> int:
        """Show progressive hints"""
        if hints_used >= len(hints):
            print("No more hints available!")
            return hints_used
        
        print(f"\n💡 HINT {hints_used + 1}: {hints[hints_used]}")
        return hints_used + 1
    
    def normalize_code(self, code: str) -> str:
        """Normalize code for comparison by removing extra whitespace and formatting"""
        # Remove comments
        code = re.sub(r'//.*?\n', '\n', code)
        code = re.sub(r'/\*.*?\*/', '', code, flags=re.DOTALL)
        
        # Normalize whitespace
        code = re.sub(r'\s+', ' ', code.strip())
        code = re.sub(r'\s*([{}();,])\s*', r'\1', code)
        code = re.sub(r'\s*([=+\-*/])\s*', r' \1 ', code)
        
        return code.lower()
    
    def check_code_similarity(self, user_code: str, expected_patterns: List[str]) -> bool:
        """Check if user code matches expected patterns"""
        normalized_user = self.normalize_code(user_code)
        
        for pattern in expected_patterns:
            normalized_pattern = self.normalize_code(pattern)
            if normalized_pattern in normalized_user:
                return True
        
        return False
    
    def class_implementation_challenge(self) -> GameResult:
        """Challenge user to implement complete classes"""
        challenges = [
            {
                "title": "Implement a Thread-Safe Singleton Pattern",
                "description": """
Create a thread-safe Singleton class called 'DatabaseManager' with the following requirements:
1. Private constructor
2. Static method getInstance() that returns the single instance
3. Thread-safe implementation (use synchronized or other concurrency techniques)
4. Private static instance variable
5. A method connect() that prints "Database connected"

Your class should handle concurrent access properly and ensure only one instance exists.
                """,
                "hints": [
                    "Use a private static variable to hold the instance",
                    "Make getInstance() synchronized or use double-checked locking",
                    "Remember to make the constructor private",
                    "Consider using 'volatile' keyword for the instance variable",
                    "Double-checked locking pattern: check null, sync, check null again"
                ],
                "expected_patterns": [
                    "private static DatabaseManager instance",
                    "private DatabaseManager()",
                    "public static synchronized DatabaseManager getInstance()",
                    "public static DatabaseManager getInstance()",
                    "public void connect()"
                ],
                "validation_keywords": ["private", "static", "synchronized", "getInstance", "DatabaseManager"]
            },
            {
                "title": "Generic Repository Pattern Implementation",
                "description": """
Implement a generic Repository class with the following specifications:
1. Generic class Repository<T> where T is the entity type
2. Private List<T> to store entities
3. Method add(T entity) to add entities
4. Method findById(int id) that returns T (assume entities have getId() method)
5. Method findAll() that returns List<T>
6. Method remove(int id) that returns boolean (true if removed)

Your implementation should be type-safe and handle null values appropriately.
                """,
                "hints": [
                    "Use <T> after class name to make it generic",
                    "Initialize the List<T> in constructor",
                    "Use instanceof or try-catch for type checking if needed",
                    "Remember to handle the case where entity is not found",
                    "Use generics properly: List<T>, not List"
                ],
                "expected_patterns": [
                    "class Repository<T>",
                    "private List<T>",
                    "public void add(T entity)",
                    "public T findById(int id)",
                    "public List<T> findAll()",
                    "public boolean remove(int id)"
                ],
                "validation_keywords": ["Repository<T>", "List<T>", "add", "findById", "findAll", "remove"]
            },
            {
                "title": "Observer Pattern with Custom Events",
                "description": """
Implement the Observer pattern with the following components:
1. Interface 'Observer' with method update(String event)
2. Class 'EventPublisher' that maintains list of observers
3. Methods: addObserver(Observer o), removeObserver(Observer o), notifyObservers(String event)
4. Class 'LogObserver' that implements Observer and prints log messages
5. Demonstrate usage by creating publisher, adding observer, and triggering events

Focus on proper decoupling and type safety.
                """,
                "hints": [
                    "Start with the Observer interface - just one method",
                    "EventPublisher should have List<Observer> as instance variable", 
                    "notifyObservers should iterate through all observers and call update()",
                    "LogObserver's update method should print the event message",
                    "Don't forget to handle null checks in your observer list operations"
                ],
                "expected_patterns": [
                    "interface Observer",
                    "void update(String event)",
                    "class EventPublisher",
                    "List<Observer>",
                    "addObserver(Observer o)",
                    "notifyObservers(String event)",
                    "class LogObserver implements Observer"
                ],
                "validation_keywords": ["Observer", "EventPublisher", "update", "addObserver", "notifyObservers", "implements"]
            }
        ]
        
        if self.difficulty == Difficulty.NIGHTMARE:
            challenges.extend([
                {
                    "title": "Concurrent Producer-Consumer with BlockingQueue",
                    "description": """
Implement a thread-safe Producer-Consumer pattern:
1. Class 'DataProcessor' with BlockingQueue<String> buffer
2. Inner class 'Producer' extends Thread, generates data every 100ms
3. Inner class 'Consumer' extends Thread, processes data with 200ms delay
4. Method startProcessing() that starts both threads
5. Proper shutdown mechanism with interrupt handling
6. Buffer should have maximum capacity of 10 items

Handle all concurrency concerns and graceful shutdown.
                    """,
                    "hints": [
                        "Use ArrayBlockingQueue<String> with capacity 10",
                        "Producer should use queue.put() to add items",
                        "Consumer should use queue.take() to remove items",
                        "Handle InterruptedException in both producer and consumer",
                        "Use Thread.sleep() for delays, check Thread.currentThread().isInterrupted()"
                    ],
                    "expected_patterns": [
                        "BlockingQueue<String>",
                        "class Producer extends Thread",
                        "class Consumer extends Thread", 
                        "queue.put(",
                        "queue.take(",
                        "InterruptedException"
                    ],
                    "validation_keywords": ["BlockingQueue", "Producer", "Consumer", "Thread", "put", "take"]
                }
            ])
        
        challenge = random.choice(challenges)
        print(f"\n🎯 {challenge['title']}")
        print("=" * 50)
        print(challenge['description'])
        print("\n📝 Write your complete Java implementation:")
        print("(Type 'hint' for a hint, 'done' when finished)")
        
        user_code = ""
        hints_used = 0
        attempts = 0
        start_time = time.time()
        time_limit = self.get_time_limit()
        
        while True:
            elapsed = time.time() - start_time
            remaining = time_limit - elapsed
            
            if remaining <= 0:
                print(f"\n⏰ Time's up!")
                print("Here's a sample solution approach:")
                for pattern in challenge['expected_patterns'][:3]:
                    print(f"  - {pattern}")
                return GameResult(False, elapsed, attempts, hints_used)
            
            print(f"\n⏱️  Time remaining: {remaining:.1f}s")
            line = input(">>> ").strip()
            
            if line.lower() == 'hint':
                hints_used = self.show_hint(challenge['hints'], hints_used)
                continue
            elif line.lower() == 'done':
                attempts += 1
                break
            else:
                user_code += line + "\n"
        
        # Validate the solution
        pattern_matches = sum(1 for pattern in challenge['expected_patterns'] 
                            if self.normalize_code(pattern) in self.normalize_code(user_code))
        keyword_matches = sum(1 for keyword in challenge['validation_keywords']
                            if keyword.lower() in user_code.lower())
        
        total_checks = len(challenge['expected_patterns']) + len(challenge['validation_keywords'])
        total_matches = pattern_matches + keyword_matches
        score_percentage = (total_matches / total_checks) * 100
        
        elapsed = time.time() - start_time
        
        if score_percentage >= 70:  # 70% threshold for success
            print(f"\n✅ Excellent implementation! Score: {score_percentage:.1f}%")
            print(f"Pattern matches: {pattern_matches}/{len(challenge['expected_patterns'])}")
            print(f"Keyword matches: {keyword_matches}/{len(challenge['validation_keywords'])}")
            return GameResult(True, elapsed, attempts, hints_used)
        else:
            print(f"\n❌ Implementation needs work. Score: {score_percentage:.1f}%")
            print(f"Pattern matches: {pattern_matches}/{len(challenge['expected_patterns'])}")
            print(f"Required patterns you might be missing:")
            for pattern in challenge['expected_patterns']:
                if self.normalize_code(pattern) not in self.normalize_code(user_code):
                    print(f"  - {pattern}")
            return GameResult(False, elapsed, attempts, hints_used)
    
    def collections_challenge(self) -> GameResult:
        """Challenge user with advanced collection operations"""
        challenges = [
            {
                "title": "Custom HashMap Implementation with Collision Handling",
                "description": """
Implement a simplified HashMap class 'MyHashMap<K,V>' with:
1. Internal array of Entry<K,V> objects (use separate chaining for collisions)
2. Static nested class Entry<K,V> with key, value, and next fields
3. Methods: put(K key, V value), get(K key), remove(K key), size()
4. Proper hashCode() calculation and collision handling via linked lists
5. Initial capacity of 16, resize when load factor > 0.75

Focus on handling hash collisions and maintaining O(1) average time complexity.
                """,
                "hints": [
                    "Use array of Entry<K,V>[], not List",
                    "Calculate index with: hash(key) % array.length",
                    "Handle collisions by chaining entries in linked list",
                    "Entry class needs: K key, V value, Entry<K,V> next",
                    "For put(): find bucket, traverse chain, update or add new entry"
                ],
                "expected_patterns": [
                    "class MyHashMap<K,V>",
                    "Entry<K,V>[]",
                    "static class Entry<K,V>",
                    "put(K key, V value)",
                    "get(K key)",
                    "Entry<K,V> next"
                ],
                "validation_keywords": ["HashMap", "Entry", "hashCode", "put", "get", "next", "chain"]
            },
            {
                "title": "Thread-Safe Bounded Queue Implementation",
                "description": """
Create a thread-safe bounded queue 'SafeQueue<T>' using:
1. Internal circular array with head and tail pointers
2. ReentrantLock for thread safety
3. Condition variables for blocking when full/empty
4. Methods: offer(T item, long timeout), poll(long timeout), size(), isEmpty()
5. Proper timeout handling and interrupt support
6. Fixed capacity provided in constructor

Ensure thread safety without busy waiting.
                """,
                "hints": [
                    "Use ReentrantLock lock = new ReentrantLock()",
                    "Create conditions: notFull = lock.newCondition(), notEmpty = lock.newCondition()",
                    "Always use lock.lock() and lock.unlock() in try-finally",
                    "Use condition.await(timeout, TimeUnit) for blocking operations",
                    "Signal conditions when state changes: notFull.signal(), notEmpty.signal()"
                ],
                "expected_patterns": [
                    "class SafeQueue<T>",
                    "ReentrantLock",
                    "Condition",
                    "offer(T item, long timeout)",
                    "poll(long timeout)",
                    "await(timeout"
                ],
                "validation_keywords": ["SafeQueue", "ReentrantLock", "Condition", "await", "signal", "timeout"]
            }
        ]
        
        challenge = random.choice(challenges)
        print(f"\n🎯 {challenge['title']}")
        print("=" * 50)
        print(challenge['description'])
        print("\n📝 Write your complete Java implementation:")
        print("(Type 'hint' for a hint, 'done' when finished)")
        
        return self._run_coding_challenge(challenge)
    
    def exception_handling_challenge(self) -> GameResult:
        """Advanced exception handling scenarios"""
        challenges = [
            {
                "title": "Custom Exception Hierarchy with Recovery Strategies",
                "description": """
Create a robust exception handling system for a file processing application:
1. Abstract class 'ProcessingException' extends Exception
2. Subclasses: 'FileNotFoundException', 'CorruptedFileException', 'ProcessingTimeoutException'
3. Class 'FileProcessor' with method processFile(String filename) that:
   - Throws appropriate exceptions based on conditions
   - Implements retry logic with exponential backoff
   - Has recovery strategies for each exception type
4. Method should attempt up to 3 retries with increasing delay
5. Include proper exception chaining and detailed error messages

Demonstrate comprehensive error handling with recovery mechanisms.
                """,
                "hints": [
                    "Use 'throw new ExceptionType(message, cause)' for exception chaining",
                    "Implement retry with: for(int attempt = 0; attempt < maxRetries; attempt++)",
                    "Use Thread.sleep(delay * (2 ^ attempt)) for exponential backoff",
                    "Catch specific exceptions and handle each differently",
                    "Always include the original exception as the cause in chains"
                ],
                "expected_patterns": [
                    "abstract class ProcessingException extends Exception",
                    "class FileNotFoundException extends ProcessingException", 
                    "class CorruptedFileException extends ProcessingException",
                    "processFile(String filename) throws",
                    "for(int attempt",
                    "Thread.sleep(",
                    "throw new"
                ],
                "validation_keywords": ["ProcessingException", "throws", "retry", "attempt", "sleep", "catch"]
            },
            {
                "title": "Resource Management with Try-With-Resources",
                "description": """
Implement automatic resource management system:
1. Interface 'ManagedResource' extends AutoCloseable
2. Class 'DatabaseConnection' implements ManagedResource with:
   - connect() method that may throw SQLException
   - executeQuery(String sql) that returns ResultSet simulation
   - Proper cleanup in close() method
3. Class 'ResourceManager' with method executeWithRetry() that:
   - Uses try-with-resources syntax
   - Implements retry logic for failed operations
   - Handles multiple resource types safely
4. Demonstrate nested try-with-resources for multiple resources

Focus on proper resource cleanup and exception propagation.
                """,
                "hints": [
                    "ManagedResource should extend AutoCloseable interface",
                    "Use try(ResourceType resource = new ResourceType()) syntax",
                    "close() method should handle cleanup and potential exceptions",
                    "For multiple resources: try(Resource1 r1 = ...; Resource2 r2 = ...)",
                    "Exceptions in close() are suppressed and added to main exception"
                ],
                "expected_patterns": [
                    "interface ManagedResource extends AutoCloseable",
                    "class DatabaseConnection implements ManagedResource",
                    "try(",
                    "close()",
                    "executeQuery(String sql)",
                    "SQLException"
                ],
                "validation_keywords": ["ManagedResource", "AutoCloseable", "try-with-resources", "close", "SQLException"]
            }
        ]
        
        challenge = random.choice(challenges)
        print(f"\n🎯 {challenge['title']}")
        print("=" * 50)
        print(challenge['description'])
        print("\n📝 Write your complete Java implementation:")
        print("(Type 'hint' for a hint, 'done' when finished)")
        
        return self._run_coding_challenge(challenge)
    
    def inheritance_polymorphism_challenge(self) -> GameResult:
        """Deep dive into inheritance and polymorphism"""
        challenges = [
            {
                "title": "Abstract Factory Pattern with Multiple Product Families",
                "description": """
Implement a complete Abstract Factory pattern for UI components:
1. Abstract class 'UIComponent' with abstract method render()
2. Abstract class 'UIFactory' with abstract methods: createButton(), createTextField()
3. Concrete classes: 'WindowsButton', 'MacButton', 'WindowsTextField', 'MacTextField'
4. Concrete factories: 'WindowsUIFactory', 'MacUIFactory'
5. Class 'Application' that uses factory to create UI without knowing specific types
6. Demonstrate polymorphic behavior with different factory implementations

Show how abstract factory enables creating families of related objects.
                """,
                "hints": [
                    "UIComponent is base class for all UI elements",
                    "Each concrete component (WindowsButton, etc.) extends UIComponent",
                    "Factory methods return UIComponent types, not concrete types",
                    "Application class should work with abstract factory and components",
                    "Use polymorphism: UIComponent component = factory.createButton()"
                ],
                "expected_patterns": [
                    "abstract class UIComponent",
                    "abstract void render()",
                    "abstract class UIFactory",
                    "abstract UIComponent createButton()",
                    "class WindowsButton extends UIComponent",
                    "class WindowsUIFactory extends UIFactory",
                    "UIComponent component = factory.createButton()"
                ],
                "validation_keywords": ["abstract", "extends", "UIComponent", "UIFactory", "polymorphism", "factory"]
            },
            {
                "title": "Template Method Pattern with Hooks",
                "description": """
Create a Template Method pattern for data processing pipeline:
1. Abstract class 'DataProcessor' with template method process()
2. Template method calls: loadData(), validateData(), transformData(), saveData()
3. Abstract methods: loadData(), saveData() (must be implemented by subclasses)
4. Concrete methods: validateData() (default implementation)
5. Hook method: shouldTransform() (default returns true, can be overridden)
6. Concrete classes: 'CSVProcessor', 'JSONProcessor' with specific implementations
7. Demonstrate how template method controls algorithm flow

Show how template method defines skeleton while allowing customization.
                """,
                "hints": [
                    "Template method 'process()' should call other methods in sequence",
                    "Abstract methods force subclasses to provide implementations",
                    "Hook methods provide optional customization points",
                    "Use 'final' for template method to prevent overriding",
                    "validateData() can have default implementation that subclasses can override"
                ],
                "expected_patterns": [
                    "abstract class DataProcessor",
                    "final void process()",
                    "abstract void loadData()",
                    "abstract void saveData()",
                    "boolean shouldTransform()",
                    "class CSVProcessor extends DataProcessor",
                    "if(shouldTransform())"
                ],
                "validation_keywords": ["abstract", "final", "template", "hook", "process", "extends"]
            }
        ]
        
        challenge = random.choice(challenges)
        print(f"\n🎯 {challenge['title']}")
        print("=" * 50)
        print(challenge['description'])
        print("\n📝 Write your complete Java implementation:")
        print("(Type 'hint' for a hint, 'done' when finished)")
        
        return self._run_coding_challenge(challenge)
    
    def interfaces_abstract_challenge(self) -> GameResult:
        """Interface and abstract class architecture challenges"""
        challenges = [
            {
                "title": "Strategy Pattern with Functional Interfaces",
                "description": """
Implement Strategy pattern using modern Java features:
1. Functional interface 'PaymentStrategy' with method processPayment(double amount)
2. Class 'PaymentProcessor' that accepts PaymentStrategy in constructor
3. Method processOrder(double amount) that delegates to strategy
4. Implement strategies as lambda expressions for: CreditCard, PayPal, BankTransfer
5. Create static factory methods in PaymentStrategy interface for each type
6. Demonstrate usage with method references and lambda expressions

Combine traditional pattern with functional programming concepts.
                """,
                "hints": [
                    "Use @FunctionalInterface annotation for PaymentStrategy",
                    "PaymentStrategy has single abstract method: void processPayment(double amount)",
                    "Static factory methods: static PaymentStrategy creditCard(), paypal(), etc.",
                    "Return lambdas from factory methods: () -> { /* implementation */ }",
                    "PaymentProcessor stores strategy and delegates calls to it"
                ],
                "expected_patterns": [
                    "@FunctionalInterface",
                    "interface PaymentStrategy",
                    "void processPayment(double amount)",
                    "static PaymentStrategy creditCard()",
                    "class PaymentProcessor",
                    "PaymentStrategy strategy",
                    "strategy.processPayment(amount)"
                ],
                "validation_keywords": ["@FunctionalInterface", "PaymentStrategy", "lambda", "static", "processPayment"]
            },
            {
                "title": "Composite Pattern with Tree Structure Operations",
                "description": """
Build a file system using Composite pattern:
1. Abstract class 'FileSystemNode' with methods: getName(), getSize(), display(int depth)
2. Class 'File' extends FileSystemNode (leaf component)
3. Class 'Directory' extends FileSystemNode (composite component)
4. Directory maintains List<FileSystemNode> children
5. Methods: addChild(FileSystemNode node), removeChild(String name), findNode(String name)
6. Implement recursive operations: calculateTotalSize(), findLargestFile()
7. Display method should show tree structure with proper indentation

Demonstrate how composite pattern handles tree structures uniformly.
                """,
                "hints": [
                    "FileSystemNode is abstract base for both files and directories",
                    "File is leaf node - getSize() returns actual file size",
                    "Directory is composite - getSize() sums all children's sizes",
                    "Use recursion in Directory's methods to traverse children",
                    "display() should use depth parameter for indentation: '  '.repeat(depth)"
                ],
                "expected_patterns": [
                    "abstract class FileSystemNode",
                    "abstract long getSize()",
                    "class File extends FileSystemNode",
                    "class Directory extends FileSystemNode",
                    "List<FileSystemNode> children",
                    "addChild(FileSystemNode node)",
                    "for(FileSystemNode child : children)"
                ],
                "validation_keywords": ["abstract", "FileSystemNode", "composite", "children", "recursive", "addChild"]
            }
        ]
        
        challenge = random.choice(challenges)
        print(f"\n🎯 {challenge['title']}")
        print("=" * 50)
        print(challenge['description'])
        print("\n📝 Write your complete Java implementation:")
        print("(Type 'hint' for a hint, 'done' when finished)")
        
        return self._run_coding_challenge(challenge)
    
    def generics_challenge(self) -> GameResult:
        """Advanced generics and type safety challenges"""
        challenges = [
            {
                "title": "Generic Repository with Type-Safe Specifications",
                "description": """
Create an advanced generic repository with specifications:
1. Interface 'Specification<T>' with method isSatisfiedBy(T entity)
2. Class 'GenericRepository<T, ID>' with methods:
   - save(T entity), findById(ID id), findAll(Specification<T> spec)
   - findFirst(Specification<T> spec), count(Specification<T> spec)
3. Implement specifications as lambda expressions or classes
4. Generic method <R> List<R> findAndTransform(Specification<T> spec, Function<T, R> mapper)
5. Demonstrate with concrete entity class and various specifications
6. Use bounded wildcards appropriately: ? extends, ? super

Show advanced generic concepts with real-world repository pattern.
                """,
                "hints": [
                    "Specification<T> is functional interface with boolean isSatisfiedBy(T entity)",
                    "Use Function<T, R> for transformation in findAndTransform method",
                    "Bounded wildcards: ? extends T for reading, ? super T for writing",
                    "Stream API works well with specifications: stream().filter(spec::isSatisfiedBy)",
                    "Generic method syntax: <R> ReturnType methodName(...)"
                ],
                "expected_patterns": [
                    "interface Specification<T>",
                    "boolean isSatisfiedBy(T entity)",
                    "class GenericRepository<T, ID>",
                    "<R> List<R> findAndTransform",
                    "Function<T, R> mapper",
                    "Specification<T> spec",
                    "spec.isSatisfiedBy("
                ],
                "validation_keywords": ["Specification", "GenericRepository", "Function", "mapper", "bounded", "wildcard"]
            }
        ]
        
        challenge = random.choice(challenges)
        print(f"\n🎯 {challenge['title']}")
        print("=" * 50)
        print(challenge['description'])
        print("\n📝 Write your complete Java implementation:")
        print("(Type 'hint' for a hint, 'done' when finished)")
        
        return self._run_coding_challenge(challenge)
    
    def lambda_streams_challenge(self) -> GameResult:
        """Advanced lambda and stream operations"""
        challenges = [
            {
                "title": "Custom Collector Implementation for Advanced Grouping",
                "description": """
Implement a custom Collector for advanced data processing:
1. Create Collector<Person, ?, Map<String, PersonStatistics>> using Collector.of()
2. PersonStatistics class with: count, averageAge, totalSalary, oldestPerson
3. Group persons by department and calculate comprehensive statistics
4. Implement all Collector methods: supplier(), accumulator(), combiner(), finisher()
5. Use parallel processing capabilities - ensure thread safety
6. Demonstrate with stream of Person objects and parallel processing

Show deep understanding of Collector internals and parallel stream processing.
                """,
                "hints": [
                    "Collector.of() takes: supplier, accumulator, combiner, finisher, characteristics",
                    "Supplier creates new Map<String, PersonStatistics>",
                    "Accumulator updates statistics for each person",
                    "Combiner merges two maps from parallel processing",
                    "Use Collector.Characteristics.CONCURRENT for thread safety"
                ],
                "expected_patterns": [
                    "Collector.of(",
                    "supplier()",
                    "accumulator()",
                    "combiner()",
                    "finisher()",
                    "Map<String, PersonStatistics>",
                    "Collector.Characteristics.CONCURRENT"
                ],
                "validation_keywords": ["Collector", "supplier", "accumulator", "combiner", "statistics", "parallel"]
            },
            {
                "title": "Functional Pipeline with Error Handling",
                "description": """
Create a robust functional processing pipeline:
1. Generic class 'Result<T>' with success/failure states (similar to Optional)
2. Methods: map(), flatMap(), filter(), orElse(), ifPresent()
3. Static factory methods: success(T value), failure(String error)
4. Pipeline class 'DataPipeline<T>' that chains operations safely
5. Implement operations: validate(), transform(), save() returning Result<T>
6. Demonstrate with complex data processing that handles errors gracefully

Build a monadic error handling system using functional programming.
                """,
                "hints": [
                    "Result<T> should wrap either value or error message",
                    "map() should only apply function if result is success",
                    "flatMap() handles Result-returning functions",
                    "Use isSuccess() boolean to check state",
                    "Chain operations with fluent interface: result.map().filter().flatMap()"
                ],
                "expected_patterns": [
                    "class Result<T>",
                    "static Result<T> success(T value)",
                    "static Result<T> failure(String error)",
                    "Result<R> map(Function<T, R> mapper)",
                    "Result<R> flatMap(Function<T, Result<R>> mapper)",
                    "boolean isSuccess()",
                    "class DataPipeline<T>"
                ],
                "validation_keywords": ["Result", "success", "failure", "map", "flatMap", "pipeline", "monadic"]
            }
        ]
        
        challenge = random.choice(challenges)
        print(f"\n🎯 {challenge['title']}")
        print("=" * 50)
        print(challenge['description'])
        print("\n📝 Write your complete Java implementation:")
        print("(Type 'hint' for a hint, 'done' when finished)")
        
        return self._run_coding_challenge(challenge)
    
    def design_patterns_challenge(self) -> GameResult:
        """Complex design pattern implementations"""
        challenges = [
            {
                "title": "Command Pattern with Undo/Redo and Macro Commands",
                "description": """
Implement comprehensive Command pattern with advanced features:
1. Interface 'Command' with methods: execute(), undo(), getDescription()
2. Abstract class 'UndoableCommand' implements Command with undo support
3. Commands: 'CreateFileCommand', 'DeleteFileCommand', 'EditFileCommand'
4. Class 'MacroCommand' that executes multiple commands as one unit
5. Class 'CommandInvoker' with methods: execute(), undo(), redo(), createMacro()
6. Maintain command history with undo/redo stack (use Deque)
7. Implement command queuing and batch execution

Show command pattern with full undo/redo capabilities and macro support.
                """,
                "hints": [
                    "Use Deque<Command> for undo stack and redo stack",
                    "MacroCommand contains List<Command> and executes all in order",
                    "For undo in MacroCommand, iterate commands in reverse order",
                    "CommandInvoker maintains current position in command history",
                    "Each command should store state needed for undo operation"
                ],
                "expected_patterns": [
                    "interface Command",
                    "void execute()",
                    "void undo()",
                    "abstract class UndoableCommand implements Command",
                    "class MacroCommand implements Command",
                    "List<Command> commands",
                    "Deque<Command>",
                    "class CommandInvoker"
                ],
                "validation_keywords": ["Command", "execute", "undo", "redo", "MacroCommand", "Deque", "history"]
            }
        ]
        
        challenge = random.choice(challenges)
        print(f"\n🎯 {challenge['title']}")
        print("=" * 50)
        print(challenge['description'])
        print("\n📝 Write your complete Java implementation:")
        print("(Type 'hint' for a hint, 'done' when finished)")
        
        return self._run_coding_challenge(challenge)
    
    def algorithm_challenge(self) -> GameResult:
        """Algorithm and logic implementation challenges"""
        challenges = [
            {
                "title": "Implement Binary Search Tree with Balancing",
                "description": """
Create a self-balancing Binary Search Tree (AVL Tree):
1. Class 'AVLNode<T>' with: data, left, right, height fields
2. Class 'AVLTree<T extends Comparable<T>>' with insert/delete/search operations
3. Methods: insert(T data), delete(T data), search(T data), getHeight()
4. Implement rotations: rotateLeft(), rotateRight(), getBalance()
5. Auto-balance after each insert/delete operation
6. Method printInOrder() for tree traversal verification
7. Include size() and isEmpty() methods

Demonstrate understanding of tree algorithms and self-balancing.
                """,
                "hints": [
                    "Height of node = 1 + max(height(left), height(right))",
                    "Balance factor = height(left) - height(right), should be -1, 0, or 1",
                    "Left rotation: newRoot = node.right, node.right = newRoot.left, newRoot.left = node",
                    "Rebalance when balance factor is < -1 or > 1",
                    "Update heights after rotations"
                ],
                "expected_patterns": [
                    "class AVLNode<T>",
                    "class AVLTree<T extends Comparable<T>>",
                    "int getHeight(AVLNode<T> node)",
                    "int getBalance(AVLNode<T> node)",
                    "AVLNode<T> rotateLeft(AVLNode<T> node)",
                    "AVLNode<T> rotateRight(AVLNode<T> node)",
                    "insert(T data)",
                    "Math.max(getHeight("
                ],
                "validation_keywords": ["AVLTree", "balance", "rotate", "height", "Comparable", "insert", "delete"]
            },
            {
                "title": "Concurrent Graph Traversal with Thread Pool",
                "description": """
Implement parallel graph traversal algorithm:
1. Class 'Graph<T>' with adjacency list representation
2. Thread-safe methods: addVertex(T vertex), addEdge(T from, T to)
3. Parallel BFS using ExecutorService and ConcurrentHashMap
4. Method parallelBFS(T start, Function<T, Boolean> processor)
5. Ensure each vertex is processed exactly once across all threads
6. Implement proper synchronization and result collection
7. Handle graph cycles and disconnected components

Show concurrent programming with complex data structures.
                """,
                "hints": [
                    "Use ConcurrentHashMap<T, List<T>> for adjacency list",
                    "ExecutorService with fixed thread pool for parallel processing",
                    "AtomicBoolean or ConcurrentHashMap to track visited vertices",
                    "BlockingQueue for thread-safe vertex queue management",
                    "CompletableFuture.allOf() to wait for all tasks completion"
                ],
                "expected_patterns": [
                    "class Graph<T>",
                    "ConcurrentHashMap<T, List<T>>",
                    "ExecutorService",
                    "parallelBFS(T start",
                    "Function<T, Boolean> processor",
                    "AtomicBoolean",
                    "BlockingQueue<T>",
                    "CompletableFuture"
                ],
                "validation_keywords": ["Graph", "parallel", "BFS", "ExecutorService", "ConcurrentHashMap", "thread-safe"]
            }
        ]
        
        challenge = random.choice(challenges)
        print(f"\n🎯 {challenge['title']}")
        print("=" * 50)
        print(challenge['description'])
        print("\n📝 Write your complete Java implementation:")
        print("(Type 'hint' for a hint, 'done' when finished)")
        
        return self._run_coding_challenge(challenge)
    
    def bug_hunt_challenge(self) -> GameResult:
        """Find and fix complex bugs in Java code"""
        challenges = [
            {
                "title": "Memory Leak and Concurrency Bug Hunt",
                "description": """
Fix all bugs in this event management system:

```java
public class EventManager {
    private static List<EventListener> listeners = new ArrayList<>();
    private Map<String, Object> cache = new HashMap<>();
    
    public void addListener(EventListener listener) {
        listeners.add(listener);
    }
    
    public void removeListener(EventListener listener) {
        // Bug: listeners list is never cleaned up
        listeners.remove(listener);
    }
    
    public void processEvent(String event) {
        for(EventListener listener : listeners) {
            new Thread(() -> {
                listener.onEvent(event);
                cache.put(event, new LargeObject());
            }).start();
        }
    }
    
    public Object getCached(String key) {
        return cache.get(key);
    }
}
```

Identify and fix: memory leaks, thread safety issues, resource management problems.
                """,
                "hints": [
                    "ArrayList is not thread-safe - use ConcurrentLinkedQueue or synchronize",
                    "HashMap is not thread-safe - use ConcurrentHashMap",
                    "Creating threads in loop is expensive - use ExecutorService", 
                    "Cache grows indefinitely - implement size limit or TTL",
                    "No way to clean up listeners properly - use WeakReference"
                ],
                "expected_patterns": [
                    "ConcurrentLinkedQueue<EventListener>",
                    "ConcurrentHashMap<String, Object>",
                    "ExecutorService",
                    "WeakReference",
                    "synchronized",
                    "cache.size()",
                    "executor.submit("
                ],
                "validation_keywords": ["thread-safe", "ConcurrentHashMap", "ExecutorService", "memory", "synchronized"]
            },
            {
                "title": "Exception Handling and Resource Leak Bugs",
                "description": """
Fix the resource management and exception handling bugs:

```java
public class FileProcessor {
    public String processFile(String filename) throws IOException {
        FileInputStream fis = new FileInputStream(filename);
        BufferedReader reader = new BufferedReader(new InputStreamReader(fis));
        StringBuilder content = new StringBuilder();
        String line;
        
        while((line = reader.readLine()) != null) {
            if(line.contains("ERROR")) {
                throw new RuntimeException("Error found in file");
            }
            content.append(line);
        }
        
        reader.close();
        return content.toString();
    }
    
    public void batchProcess(List<String> files) {
        for(String file : files) {
            try {
                processFile(file);
            } catch(IOException e) {
                continue; // Bug: swallowing exceptions
            }
        }
    }
}
```

Fix: resource leaks, improper exception handling, missing cleanup.
                """,
                "hints": [
                    "Use try-with-resources for automatic resource management",
                    "Don't swallow exceptions - log them or rethrow as appropriate",
                    "Resources not closed if exception occurs before close()",
                    "RuntimeException bypasses IOException handling",
                    "Use Files.readAllLines() or similar for cleaner code"
                ],
                "expected_patterns": [
                    "try(FileInputStream fis = new FileInputStream(filename);",
                    "try(BufferedReader reader =",
                    "catch(IOException e) {",
                    "logger.error(",
                    "finally {",
                    "Files.readAllLines("
                ],
                "validation_keywords": ["try-with-resources", "finally", "logger", "exception", "resource", "cleanup"]
            }
        ]
        
        challenge = random.choice(challenges)
        print(f"\n🎯 {challenge['title']}")
        print("=" * 50)
        print(challenge['description'])
        print("\n🔧 Rewrite the code fixing all identified bugs:")
        print("(Type 'hint' for a hint, 'done' when finished)")
        
        return self._run_coding_challenge(challenge)
    
    def advanced_features_challenge(self) -> GameResult:
        """Advanced Java features and modern capabilities"""
        challenges = [
            {
                "title": "Annotation Processing and Reflection Magic",
                "description": """
Create a dependency injection framework using annotations and reflection:
1. Annotations: @Injectable, @Inject, @Singleton
2. Class 'DIContainer' that scans classes and creates instances
3. Method register(Class<?> clazz) - registers class for injection
4. Method <T> T getInstance(Class<T> clazz) - returns instance with dependencies injected
5. Support constructor injection and field injection
6. Handle circular dependencies detection
7. Implement singleton lifecycle management

Build a mini-framework showing reflection and annotation processing.
                """,
                "hints": [
                    "Use @Retention(RetentionPolicy.RUNTIME) for annotations",
                    "Class.getDeclaredConstructors() to find constructors",
                    "Constructor.getParameterTypes() for dependency types",
                    "Field.setAccessible(true) before setting private fields",
                    "Map<Class<?>, Object> to store singleton instances"
                ],
                "expected_patterns": [
                    "@Retention(RetentionPolicy.RUNTIME)",
                    "@interface Injectable",
                    "@interface Inject",
                    "class DIContainer",
                    "Class.getDeclaredConstructors()",
                    "field.setAccessible(true)",
                    "Map<Class<?>, Object>",
                    "constructor.newInstance("
                ],
                "validation_keywords": ["annotation", "reflection", "Injectable", "Inject", "getDeclaredConstructors", "newInstance"]
            },
            {
                "title": "CompletableFuture Pipeline with Custom Executors",
                "description": """
Build an asynchronous processing pipeline using CompletableFuture:
1. Class 'AsyncPipeline<T, R>' for chaining async operations
2. Custom executors: IO-bound, CPU-bound, scheduled operations
3. Methods: stage(), parallel(), timeout(), fallback(), collect()
4. Error handling and retry mechanisms with exponential backoff
5. Demonstrate with file processing: read -> validate -> transform -> save
6. Include monitoring and metrics collection for pipeline performance

Show advanced async programming with proper resource management.
                """,
                "hints": [
                    "Use Executors.newFixedThreadPool() for different executor types",
                    "CompletableFuture.supplyAsync() for starting async chains",
                    "thenComposeAsync() for chaining async operations",
                    "CompletableFuture.allOf() for parallel execution",
                    "orTimeout() and completeOnTimeout() for timeout handling"
                ],
                "expected_patterns": [
                    "class AsyncPipeline<T, R>",
                    "CompletableFuture<T>",
                    "ExecutorService",
                    "supplyAsync(",
                    "thenComposeAsync(",
                    "CompletableFuture.allOf(",
                    "orTimeout(",
                    "exceptionally("
                ],
                "validation_keywords": ["CompletableFuture", "async", "ExecutorService", "pipeline", "timeout", "exceptionally"]
            }
        ]
        
        challenge = random.choice(challenges)
        print(f"\n🎯 {challenge['title']}")
        print("=" * 50)
        print(challenge['description'])
        print("\n📝 Write your complete Java implementation:")
        print("(Type 'hint' for a hint, 'done' when finished)")
        
        return self._run_coding_challenge(challenge)
    
    def _run_coding_challenge(self, challenge: Dict[str, Any]) -> GameResult:
        """Common logic for running coding challenges"""
        user_code = ""
        hints_used = 0
        attempts = 0
        start_time = time.time()
        time_limit = self.get_time_limit()
        
        while True:
            elapsed = time.time() - start_time
            remaining = time_limit - elapsed
            
            if remaining <= 0:
                print(f"\n⏰ Time's up!")
                print("Here's what your solution should include:")
                for pattern in challenge['expected_patterns'][:3]:
                    print(f"  - {pattern}")
                return GameResult(False, elapsed, attempts, hints_used)
            
            print(f"\n⏱️  Time remaining: {remaining:.1f}s")
            line = input(">>> ").strip()
            
            if line.lower() == 'hint':
                hints_used = self.show_hint(challenge['hints'], hints_used)
                continue
            elif line.lower() == 'done':
                attempts += 1
                break
            else:
                user_code += line + "\n"
        
        # Validate the solution
        pattern_matches = sum(1 for pattern in challenge['expected_patterns'] 
                            if self.normalize_code(pattern) in self.normalize_code(user_code))
        keyword_matches = sum(1 for keyword in challenge['validation_keywords']
                            if keyword.lower() in user_code.lower())
        
        total_checks = len(challenge['expected_patterns']) + len(challenge['validation_keywords'])
        total_matches = pattern_matches + keyword_matches
        score_percentage = (total_matches / total_checks) * 100
        
        elapsed = time.time() - start_time
        
        if score_percentage >= 70:  # 70% threshold for success
            print(f"\n✅ Excellent implementation! Score: {score_percentage:.1f}%")
            print(f"Pattern matches: {pattern_matches}/{len(challenge['expected_patterns'])}")
            print(f"Keyword matches: {keyword_matches}/{len(challenge['validation_keywords'])}")
            return GameResult(True, elapsed, attempts, hints_used)
        else:
            print(f"\n❌ Implementation needs work. Score: {score_percentage:.1f}%")
            print(f"Pattern matches: {pattern_matches}/{len(challenge['expected_patterns'])}")
            print(f"Missing key patterns:")
            for pattern in challenge['expected_patterns']:
                if self.normalize_code(pattern) not in self.normalize_code(user_code):
                    print(f"  - {pattern}")
            return GameResult(False, elapsed, attempts, hints_used)
    
    def show_stats(self):
        """Show comprehensive game statistics"""
        if self.total_games == 0:
            accuracy = 0
        else:
            accuracy = (self.score / self.total_games) * 100
        
        print(f"\n=== JAVA MASTERY STATISTICS ===")
        print(f"Total Score: {self.score}")
        print(f"Games Played: {self.total_games}")
        print(f"Accuracy: {accuracy:.1f}%")
        print(f"Total Hints Used: {self.hints_used_total}")
        print(f"Current Difficulty: {self.difficulty.value}")
        
        # Calculate mastery level
        if accuracy >= 90 and self.hints_used_total / max(1, self.total_games) < 2:
            level = "🏆 Java Architect - Master of Enterprise Patterns!"
        elif accuracy >= 80 and self.difficulty.value in ['hard', 'nightmare']:
            level = "🚀 Senior Java Engineer - Advanced OOP Specialist!"
        elif accuracy >= 70:
            level = "💼 Java Developer - Solid Foundation Builder!"
        elif accuracy >= 60:
            level = "📈 Java Apprentice - Growing Strong!"
        elif accuracy >= 50:
            level = "💡 Java Student - Learning the Craft!"
        else:
            level = "🌱 Java Beginner - Every Expert Started Here!"
        
        print(f"\nMastery Level: {level}")
        
        if self.total_games > 0:
            avg_hints = self.hints_used_total / self.total_games
            print(f"Average Hints per Game: {avg_hints:.1f}")
            
            if avg_hints < 1:
                print("💪 Impressive! You're solving challenges with minimal help!")
            elif avg_hints < 2:
                print("👍 Good problem-solving skills with occasional guidance!")
            else:
                print("📚 Keep practicing! The hints are helping you learn!")
        
        input("\nPress Enter to continue...")
    
    def update_score(self, result: GameResult):
        """Update score based on comprehensive performance metrics"""
        self.total_games += 1
        self.hints_used_total += result.hints_used
        
        if result.correct:
            # Base points for correct solution
            base_points = 100
            
            # Time bonus (up to 50 points)
            time_limit = self.get_time_limit()
            time_bonus = max(0, int(50 * (time_limit - result.time_taken) / time_limit))
            
            # Attempt bonus (fewer attempts = more points)
            attempt_bonus = max(0, 30 - (result.attempts - 1) * 10)
            
            # Hint penalty (using hints reduces score)
            hint_penalty = result.hints_used * 20
            
            # Difficulty multiplier
            difficulty_multiplier = {
                Difficulty.NOOB: 1.0,
                Difficulty.EASY: 1.2,
                Difficulty.MEDIUM: 1.5,
                Difficulty.HARD: 2.0,
                Difficulty.NIGHTMARE: 3.0
            }[self.difficulty]
            
            total_points = int((base_points + time_bonus + attempt_bonus - hint_penalty) * difficulty_multiplier)
            total_points = max(10, total_points)  # Minimum 10 points for correct solution
            
            self.score += total_points
            
            print(f"\n🎉 Challenge completed! You earned {total_points} points!")
            print(f"  Base points: {base_points}")
            if time_bonus > 0:
                print(f"  Speed bonus: +{time_bonus}")
            if attempt_bonus > 0:
                print(f"  Accuracy bonus: +{attempt_bonus}")
            if hint_penalty > 0:
                print(f"  Hint penalty: -{hint_penalty}")
            print(f"  Difficulty multiplier: x{difficulty_multiplier}")
            
            # Motivational messages based on performance
            if result.hints_used == 0 and result.attempts == 1:
                print("🔥 FLAWLESS EXECUTION! You're a Java virtuoso!")
            elif result.hints_used <= 1:
                print("⭐ Excellent work! Minimal assistance needed!")
            elif result.time_taken < self.get_time_limit() * 0.5:
                print("⚡ Lightning fast! Your fingers are on fire!")
        else:
            print("💪 Challenge not completed, but every attempt builds expertise!")
            print("Keep coding! The path to mastery requires persistence!")
    
    def run(self):
        """Main game loop with enhanced experience"""
        games = {
            "1": self.class_implementation_challenge,
            "2": self.collections_challenge,
            "3": self.exception_handling_challenge,
            "4": self.inheritance_polymorphism_challenge,
            "5": self.interfaces_abstract_challenge,
            "6": self.generics_challenge,
            "7": self.lambda_streams_challenge,
            "8": self.design_patterns_challenge,
            "9": self.algorithm_challenge,
            "10": self.bug_hunt_challenge,
            "11": self.advanced_features_challenge,
        }
        
        print("🎯 Welcome to Java Be Good - Technical Coding Edition!")
        print("═" * 60)
        print("Master Java through hands-on coding challenges!")
        print("Write real code, solve complex problems, build expertise!")
        print("\n💡 Pro Tips:")
        print("  • Type 'hint' during any challenge for guidance")
        print("  • Type 'done' when you've finished your implementation")
        print("  • Focus on clean, well-structured code")
        print("  • Challenge yourself with higher difficulties!")
        print("\n☕ 'The best way to learn Java is to write Java!' ☕")
        
        while True:
            self.clear_screen()
            self.print_banner()
            choice = self.show_menu()
            
            if choice == "q":
                print("\n🎓 Thanks for coding with Java Be Good!")
                print(f"Final Score: {self.score} | Challenges Completed: {self.total_games}")
                print("Your Java journey continues! Keep building amazing software! ☕🚀")
                break
            elif choice == "12":
                self.set_difficulty()
            elif choice == "13":
                self.show_stats()
            elif choice in games:
                print(f"\n🚀 Initializing challenge environment...")
                print("Get ready to code like a pro! 💻")
                time.sleep(2)
                result = games[choice]()
                self.update_score(result)
                input("\nPress Enter to return to main menu...")
            
            time.sleep(1)

if __name__ == "__main__":
    game = JavaBeGood()
    try:
        game.run()
    except KeyboardInterrupt:
        print("\n\n🛑 Game interrupted. Thanks for coding with Java Be Good!")
    except Exception as e:
        print(f"\n💥 An error occurred: {e}")
        print("Thanks for playing Java Be Good!")
