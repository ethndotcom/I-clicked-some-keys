#!/usr/bin/env python3
"""
Python Be Good - Enhanced Technical Coding Game
Practice Python programming with hands-on coding challenges
"""

import random
import time
import os
import sys
from typing import List, Dict, Any, Callable, Optional
from dataclasses import dataclass
from enum import Enum

class Difficulty(Enum):
    NOOB = "noob"
    EASY = "easy"
    MEDIUM = "medium"
    HARD = "hard"
    NIGHTMARE = "nightmare"

@dataclass
class GameResult:
    correct: bool
    time_taken: float
    attempts: int
    hints_used: int

@dataclass
class Challenge:
    description: str
    detailed_requirements: str
    hints: List[str]
    solution: str
    test_cases: List[tuple]
    expected_output: Any = None

class PythonBeGood:
    def __init__(self):
        self.score = 0
        self.total_games = 0
        self.difficulty = Difficulty.EASY
        self.current_hints_used = 0
        
    def clear_screen(self):
        """Clear the terminal screen"""
        os.system('cls' if os.name == 'nt' else 'clear')
    
    def print_banner(self):
        """Print the game banner"""
        banner = """
‚ïî‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïó
‚ïë           PYTHON BE GOOD              ‚ïë
‚ïë   Technical Python Coding Practice   ‚ïë
‚ïö‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïù
        """
        print(banner)
        print(f"Score: {self.score} | Games Played: {self.total_games} | Difficulty: {self.difficulty.value}")
        print("-" * 40)
    
    def show_menu(self) -> str:
        """Show main menu and get user choice"""
        options = {
            "1": "List Comprehension Mastery",
            "2": "Dictionary & Data Manipulation",
            "3": "String Processing & Regex",
            "4": "Function Implementation",
            "5": "Algorithm & Logic Challenges",
            "6": "Bug Detection & Fixing",
            "7": "Data Structure Operations",
            "8": "Change Difficulty",
            "9": "View Stats",
            "q": "Quit"
        }
        
        print("\nChoose your technical challenge:")
        for key, value in options.items():
            print(f"{key}. {value}")
        
        while True:
            choice = input("\nEnter your choice: ").strip().lower()
            if choice in options:
                return choice
            print("Invalid choice! Please try again.")
    
    def set_difficulty(self):
        """Allow user to change difficulty"""
        print("\nSelect difficulty:")
        for i, diff in enumerate(Difficulty, 1):
            print(f"{i}. {diff.value.title()}")
        
        try:
            choice = int(input("Enter choice (1-5): "))
            if 1 <= choice <= 5:
                self.difficulty = list(Difficulty)[choice - 1]
                print(f"Difficulty set to: {self.difficulty.value}")
            else:
                print("Invalid choice!")
        except ValueError:
            print("Invalid input!")
        
        input("Press Enter to continue...")
    
    def get_time_limit(self) -> float:
        """Get time limit based on difficulty"""
        limits = {
            Difficulty.NOOB: 180.0,
            Difficulty.EASY: 120.0,
            Difficulty.MEDIUM: 60.0,
            Difficulty.HARD: 30.0,
            Difficulty.NIGHTMARE: 15.0
        }
        return limits[self.difficulty]
    
    def show_hint(self, hints: List[str]) -> bool:
        """Show a hint to the user"""
        if self.current_hints_used >= len(hints):
            print("No more hints available!")
            return False
        
        print(f"\nüí° HINT {self.current_hints_used + 1}: {hints[self.current_hints_used]}")
        self.current_hints_used += 1
        return True
    
    def execute_challenge(self, challenge: Challenge) -> GameResult:
        """Execute a coding challenge with hint system"""
        self.current_hints_used = 0
        
        print(f"\n{challenge.description}")
        print("=" * 50)
        print(challenge.detailed_requirements)
        print("\nCommands:")
        print("- Type 'hint' for a hint")
        print("- Type 'quit' to give up")
        print("- Enter your Python code to test it")
        print("-" * 50)
        
        attempts = 0
        start_time = time.time()
        time_limit = self.get_time_limit()
        
        while True:
            attempts += 1
            elapsed = time.time() - start_time
            remaining = time_limit - elapsed
            
            if remaining <= 0:
                print(f"\n‚è∞ Time's up! Here's the solution:")
                print(f"```python\n{challenge.solution}\n```")
                return GameResult(False, elapsed, attempts, self.current_hints_used)
            
            print(f"\n‚è±Ô∏è  Time remaining: {remaining:.1f}s | Attempt: {attempts}")
            user_input = input(">>> ").strip()
            
            if user_input.lower() == 'hint':
                self.show_hint(challenge.hints)
                continue
            elif user_input.lower() == 'quit':
                print(f"\nüè≥Ô∏è  Solution:")
                print(f"```python\n{challenge.solution}\n```")
                return GameResult(False, elapsed, attempts, self.current_hints_used)
            
            try:
                # Test the user's code
                if self.test_code(user_input, challenge):
                    elapsed = time.time() - start_time
                    print(f"\nüéâ CORRECT! Time: {elapsed:.2f}s, Attempts: {attempts}, Hints: {self.current_hints_used}")
                    return GameResult(True, elapsed, attempts, self.current_hints_used)
                    
            except Exception as e:
                print(f"‚ùå Error in your code: {e}")
                print("Check your syntax and try again!")
    
    def test_code(self, user_code: str, challenge: Challenge) -> bool:
        """Test user's code against challenge requirements"""
        try:
            if challenge.test_cases:
                # For function challenges
                local_vars = {}
                exec(user_code, {}, local_vars)
                
                if not local_vars:
                    print("‚ùå No function defined!")
                    return False
                
                # Get the function
                func_name = list(local_vars.keys())[0]
                func = local_vars[func_name]
                
                # Test all cases
                for i, test_case in enumerate(challenge.test_cases):
                    if len(test_case) == 2:
                        input_val, expected = test_case
                        if isinstance(input_val, tuple):
                            result = func(*input_val)
                        else:
                            result = func(input_val)
                    else:
                        *inputs, expected = test_case
                        result = func(*inputs)
                    
                    if result != expected:
                        print(f"‚ùå Test case {i+1} failed:")
                        print(f"   Input: {test_case[:-1]}")
                        print(f"   Expected: {expected}")
                        print(f"   Got: {result}")
                        return False
                
                print("‚úÖ All test cases passed!")
                return True
            else:
                # For expression challenges
                result = eval(user_code)
                if result == challenge.expected_output:
                    print(f"‚úÖ Correct! Result: {result}")
                    return True
                else:
                    print(f"‚ùå Expected: {challenge.expected_output}, Got: {result}")
                    return False
                    
        except Exception as e:
            raise e
    
    def list_comprehension_challenge(self) -> GameResult:
        """Advanced list comprehension challenges"""
        challenges = [
            Challenge(
                description="üî• NESTED LIST FLATTENING",
                detailed_requirements="""
Write a list comprehension that flattens a nested list structure.

Given: nested_list = [[1, 2], [3, 4, 5], [6]]
Goal: Create a flat list [1, 2, 3, 4, 5, 6]

Requirements:
- Must use list comprehension
- Should work for any nested list structure (one level deep)
- Your code should handle the variable 'nested_list'
                """,
                hints=[
                    "Think about iterating through each sublist, then through each item",
                    "Use nested for loops in your comprehension: [item for sublist in ... for item in ...]",
                    "The syntax is: [item for sublist in nested_list for item in sublist]"
                ],
                solution="[item for sublist in nested_list for item in sublist]",
                test_cases=[],
                expected_output=[1, 2, 3, 4, 5, 6]
            ),
            Challenge(
                description="üéØ CONDITIONAL FILTERING WITH TRANSFORMATION",
                detailed_requirements="""
Create a list comprehension that processes a list of numbers.

Given: numbers = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]
Goal: Get squares of even numbers only

Requirements:
- Use list comprehension with conditional
- Square each number that is even
- Filter out odd numbers completely
- Result should be [4, 16, 36, 64, 100]
                """,
                hints=[
                    "Use 'if' condition at the end of comprehension to filter",
                    "Apply transformation (squaring) before the conditional",
                    "Structure: [x**2 for x in numbers if condition]"
                ],
                solution="[x**2 for x in numbers if x % 2 == 0]",
                test_cases=[],
                expected_output=[4, 16, 36, 64, 100]
            )
        ]
        
        challenge = random.choice(challenges)
        
        # Set up the test environment
        if "nested_list" in challenge.detailed_requirements:
            exec("nested_list = [[1, 2], [3, 4, 5], [6]]", globals())
        elif "numbers" in challenge.detailed_requirements:
            exec("numbers = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]", globals())
        
        return self.execute_challenge(challenge)
    
    def dictionary_challenge(self) -> GameResult:
        """Advanced dictionary manipulation challenges"""
        challenges = [
            Challenge(
                description="üóÇÔ∏è  DICTIONARY INVERSION WITH GROUPING",
                detailed_requirements="""
Write code to invert a dictionary where values become keys and keys become values.
Handle cases where multiple keys have the same value by grouping them.

Given: data = {'a': 1, 'b': 2, 'c': 1, 'd': 3, 'e': 2}
Goal: {1: ['a', 'c'], 2: ['b', 'e'], 3: ['d']}

Requirements:
- Invert key-value pairs
- Group original keys that had the same value
- Values should be lists of keys
- Use dictionary comprehension or combination of dict operations
                """,
                hints=[
                    "You need to group keys by their values first",
                    "Consider using a loop to build groups, or use dict comprehension with a helper",
                    "One approach: {v: [k for k, val in data.items() if val == v] for v in set(data.values())}"
                ],
                solution="{v: [k for k, val in data.items() if val == v] for v in set(data.values())}",
                test_cases=[],
                expected_output={1: ['a', 'c'], 2: ['b', 'e'], 3: ['d']}
            ),
            Challenge(
                description="üîÑ NESTED DICTIONARY PROCESSING",
                detailed_requirements="""
Extract and transform data from a nested dictionary structure.

Given: students = {
    'math': {'alice': 85, 'bob': 92},
    'science': {'alice': 78, 'bob': 88, 'charlie': 95}
}

Goal: Create a student-centered view with average scores
Result: {'alice': 81.5, 'bob': 90.0, 'charlie': 95.0}

Requirements:
- Calculate average score per student across all subjects
- Handle students who don't have scores in all subjects
- Use dictionary comprehension or dict operations
                """,
                hints=[
                    "First, collect all unique student names across all subjects",
                    "For each student, find all their scores across subjects",
                    "Calculate average of their scores"
                ],
                solution="{ student: sum(subject_scores[student] for subject_scores in students.values() if student in subject_scores) / sum(1 for subject_scores in students.values() if student in subject_scores) for student in set().union(*[subject_scores.keys() for subject_scores in students.values()]) }",
                test_cases=[],
                expected_output={'alice': 81.5, 'bob': 90.0, 'charlie': 95.0}
            )
        ]
        
        challenge = random.choice(challenges)
        
        # Set up test environment
        if "data" in challenge.detailed_requirements:
            exec("data = {'a': 1, 'b': 2, 'c': 1, 'd': 3, 'e': 2}", globals())
        elif "students" in challenge.detailed_requirements:
            exec("students = {'math': {'alice': 85, 'bob': 92}, 'science': {'alice': 78, 'bob': 88, 'charlie': 95}}", globals())
        
        return self.execute_challenge(challenge)
    
    def string_challenge(self) -> GameResult:
        """Advanced string processing challenges"""
        challenges = [
            Challenge(
                description="üìù ADVANCED STRING PARSING",
                detailed_requirements="""
Parse and extract information from a formatted string.

Given: log_entry = "2024-01-15 14:30:22 ERROR user_id=12345 action=login message='Invalid password attempt'"
Goal: Extract into dictionary: {
    'timestamp': '2024-01-15 14:30:22',
    'level': 'ERROR',
    'user_id': '12345',
    'action': 'login',
    'message': 'Invalid password attempt'
}

Requirements:
- Parse the log entry string
- Extract all key-value pairs
- Handle quoted values correctly
- Return as a dictionary
                """,
                hints=[
                    "Split the string into parts and process each part",
                    "Use string methods like split(), strip(), and slice notation",
                    "For quoted values, you'll need to handle the quotes specially"
                ],
                solution="{'timestamp': log_entry[:19], 'level': log_entry.split()[2], 'user_id': log_entry.split('user_id=')[1].split()[0], 'action': log_entry.split('action=')[1].split()[0], 'message': log_entry.split(\"message='\")[1].rstrip(\"'\")}",
                test_cases=[],
                expected_output={
                    'timestamp': '2024-01-15 14:30:22',
                    'level': 'ERROR', 
                    'user_id': '12345',
                    'action': 'login',
                    'message': 'Invalid password attempt'
                }
            )
        ]
        
        challenge = random.choice(challenges)
        exec("log_entry = \"2024-01-15 14:30:22 ERROR user_id=12345 action=login message='Invalid password attempt'\"", globals())
        
        return self.execute_challenge(challenge)
    
    def function_challenge(self) -> GameResult:
        """Advanced function implementation challenges"""
        challenges = [
            Challenge(
                description="‚ö° RECURSIVE FUNCTION IMPLEMENTATION",
                detailed_requirements="""
Implement a recursive function to calculate the nth Fibonacci number.

Function signature: fibonacci(n)

Requirements:
- Must use recursion (not loops)
- Handle base cases: fibonacci(0) = 0, fibonacci(1) = 1
- For n > 1: fibonacci(n) = fibonacci(n-1) + fibonacci(n-2)
- Should work for reasonable values of n

Test cases will verify correctness for multiple inputs.
                """,
                hints=[
                    "Define base cases first: if n == 0 return 0, if n == 1 return 1",
                    "For other cases, return the sum of the two previous fibonacci numbers",
                    "def fibonacci(n): return 0 if n == 0 else 1 if n == 1 else fibonacci(n-1) + fibonacci(n-2)"
                ],
                solution="def fibonacci(n):\n    if n == 0:\n        return 0\n    elif n == 1:\n        return 1\n    else:\n        return fibonacci(n-1) + fibonacci(n-2)",
                test_cases=[
                    (0, 0), (1, 1), (2, 1), (3, 2), (4, 3), (5, 5), (6, 8)
                ]
            ),
            Challenge(
                description="üîß HIGHER-ORDER FUNCTION",
                detailed_requirements="""
Create a function that takes another function and a list, applies the function to each element,
and returns only the results that are greater than a threshold.

Function signature: filter_and_transform(func, data, threshold)

Requirements:
- Apply 'func' to each element in 'data'
- Keep only results greater than 'threshold'
- Return as a list
- Example: filter_and_transform(lambda x: x**2, [1,2,3,4,5], 10) ‚Üí [16, 25]

The function should be generic and work with any function and data.
                """,
                hints=[
                    "Use a list comprehension with filtering",
                    "Apply the function first, then check if result > threshold",
                    "Structure: [func(x) for x in data if func(x) > threshold]"
                ],
                solution="def filter_and_transform(func, data, threshold):\n    return [func(x) for x in data if func(x) > threshold]",
                test_cases=[
                    ((lambda x: x**2, [1,2,3,4,5], 10), [16, 25]),
                    ((lambda x: x*3, [1,2,3,4], 5), [9, 12]),
                    ((lambda x: x+10, [1,2,3], 12), [13])
                ]
            )
        ]
        
        return self.execute_challenge(random.choice(challenges))
    
    def algorithm_challenge(self) -> GameResult:
        """Complex algorithmic challenges"""
        challenges = [
            Challenge(
                description="üßÆ ALGORITHM: TWO SUM PROBLEM",
                detailed_requirements="""
Implement a function that finds two numbers in a list that add up to a target sum.

Function signature: two_sum(nums, target)

Requirements:
- Return indices of the two numbers that add up to target
- You may assume exactly one solution exists
- Don't use the same element twice
- Example: two_sum([2, 7, 11, 15], 9) ‚Üí [0, 1] (because nums[0] + nums[1] = 2 + 7 = 9)

Optimize for time complexity if possible.
                """,
                hints=[
                    "Try the brute force approach first: nested loops checking all pairs",
                    "For each number, check if (target - number) exists in the remaining list",
                    "Use enumerate() to get both index and value"
                ],
                solution="def two_sum(nums, target):\n    for i in range(len(nums)):\n        for j in range(i+1, len(nums)):\n            if nums[i] + nums[j] == target:\n                return [i, j]",
                test_cases=[
                    (([2, 7, 11, 15], 9), [0, 1]),
                    (([3, 2, 4], 6), [1, 2]),
                    (([3, 3], 6), [0, 1])
                ]
            )
        ]
        
        return self.execute_challenge(random.choice(challenges))
    
    def bug_hunt_challenge(self) -> GameResult:
        """Debug broken code challenges"""
        challenges = [
            Challenge(
                description="üêõ DEBUG: BROKEN SORTING FUNCTION",
                detailed_requirements="""
Fix this broken bubble sort implementation:

```python
def bubble_sort(arr):
    n = len(arr)
    for i in range(n):
        for j in range(0, n-i):
            if arr[j] > arr[j+1]:
                arr[j], arr[j+1] = arr[j+1], arr[j]
    return arr
```

The function should sort a list in ascending order but has a bug.
Figure out what's wrong and provide the corrected version.

Requirements:
- Fix the bug(s) in the code
- Function should sort [64, 34, 25, 12, 22, 11, 90] correctly
- Must still be bubble sort algorithm
                """,
                hints=[
                    "Look at the range in the inner loop - what happens when j reaches n-i?",
                    "The inner loop goes one step too far and causes index out of bounds",
                    "Change range(0, n-i) to range(0, n-i-1)"
                ],
                solution="def bubble_sort(arr):\n    n = len(arr)\n    for i in range(n):\n        for j in range(0, n-i-1):\n            if arr[j] > arr[j+1]:\n                arr[j], arr[j+1] = arr[j+1], arr[j]\n    return arr",
                test_cases=[
                    ([64, 34, 25, 12, 22, 11, 90], [11, 12, 22, 25, 34, 64, 90]),
                    ([5, 2, 8, 1, 9], [1, 2, 5, 8, 9])
                ]
            )
        ]
        
        return self.execute_challenge(random.choice(challenges))
    
    def data_structure_challenge(self) -> GameResult:
        """Advanced data structure implementation"""
        challenges = [
            Challenge(
                description="üìö IMPLEMENT A STACK CLASS",
                detailed_requirements="""
Implement a Stack class with the following methods:

- push(item): Add item to top of stack
- pop(): Remove and return top item (return None if empty)
- peek(): Return top item without removing (return None if empty)  
- is_empty(): Return True if stack is empty
- size(): Return number of items in stack

Requirements:
- Use a list internally to store items
- Handle edge cases (popping from empty stack)
- All methods should work correctly

Your class will be tested with various operations.
                """,
                hints=[
                    "Use self.items = [] to store the stack data",
                    "push() should append to the list, pop() should remove from end",
                    "Use len() for size and check if list is empty"
                ],
                solution="""class Stack:
    def __init__(self):
        self.items = []
    
    def push(self, item):
        self.items.append(item)
    
    def pop(self):
        return self.items.pop() if self.items else None
    
    def peek(self):
        return self.items[-1] if self.items else None
    
    def is_empty(self):
        return len(self.items) == 0
    
    def size(self):
        return len(self.items)""",
                test_cases=[
                    # This will be tested differently due to class nature
                ]
            )
        ]
        
        challenge = random.choice(challenges)
        
        # Special handling for class implementation
        print(f"\n{challenge.description}")
        print("=" * 50)
        print(challenge.detailed_requirements)
        print("\nCommands:")
        print("- Type 'hint' for a hint")
        print("- Type 'quit' to give up")
        print("- Enter your complete class definition")
        print("-" * 50)
        
        self.current_hints_used = 0
        attempts = 0
        start_time = time.time()
        time_limit = self.get_time_limit() * 2  # More time for class implementation
        
        while True:
            attempts += 1
            elapsed = time.time() - start_time
            remaining = time_limit - elapsed
            
            if remaining <= 0:
                print(f"\n‚è∞ Time's up! Here's the solution:")
                print(f"```python\n{challenge.solution}\n```")
                return GameResult(False, elapsed, attempts, self.current_hints_used)
            
            print(f"\n‚è±Ô∏è  Time remaining: {remaining:.1f}s | Attempt: {attempts}")
            user_input = input(">>> ").strip()
            
            if user_input.lower() == 'hint':
                self.show_hint(challenge.hints)
                continue
            elif user_input.lower() == 'quit':
                print(f"\nüè≥Ô∏è  Solution:")
                print(f"```python\n{challenge.solution}\n```")
                return GameResult(False, elapsed, attempts, self.current_hints_used)
            
            try:
                # Test the Stack class
                local_vars = {}
                exec(user_input, {}, local_vars)
                
                if 'Stack' not in local_vars:
                    print("‚ùå No Stack class found!")
                    continue
                
                # Test the implementation
                stack = local_vars['Stack']()
                
                # Test basic operations
                tests_passed = 0
                total_tests = 8
                
                # Test 1: Empty stack
                if stack.is_empty() and stack.size() == 0:
                    tests_passed += 1
                
                # Test 2: Push and size
                stack.push(1)
                if stack.size() == 1 and not stack.is_empty():
                    tests_passed += 1
                
                # Test 3: Peek
                if stack.peek() == 1:
                    tests_passed += 1
                
                # Test 4: Push more items
                stack.push(2)
                stack.push(3)
                if stack.size() == 3 and stack.peek() == 3:
                    tests_passed += 1
                
                # Test 5: Pop
                if stack.pop() == 3 and stack.size() == 2:
                    tests_passed += 1
                
                # Test 6: Pop again
                if stack.pop() == 2 and stack.peek() == 1:
                    tests_passed += 1
                
                # Test 7: Pop last
                if stack.pop() == 1 and stack.is_empty():
                    tests_passed += 1
                
                # Test 8: Pop from empty
                if stack.pop() is None and stack.peek() is None:
                    tests_passed += 1
                
                print(f"‚úÖ Passed {tests_passed}/{total_tests} tests")
                
                if tests_passed == total_tests:
                    elapsed = time.time() - start_time
                    print(f"\nüéâ PERFECT! All tests passed! Time: {elapsed:.2f}s, Attempts: {attempts}, Hints: {self.current_hints_used}")
                    return GameResult(True, elapsed, attempts, self.current_hints_used)
                    
            except Exception as e:
                print(f"‚ùå Error in your code: {e}")
    
    def show_stats(self):
        """Show detailed game statistics"""
        if self.total_games == 0:
            accuracy = 0
        else:
            accuracy = (self.score / self.total_games) * 100
        
        print(f"\n=== TECHNICAL CODING STATISTICS ===")
        print(f"Total Score: {self.score}")
        print(f"Games Played: {self.total_games}")
        print(f"Success Rate: {accuracy:.1f}%")
        print(f"Current Difficulty: {self.difficulty.value}")
        
        # Performance metrics
        if accuracy >= 80:
            print("üèÜ EXPERT LEVEL - Outstanding performance!")
        elif accuracy >= 60:
            print("‚≠ê PROFICIENT - Keep up the good work!")
        elif accuracy >= 40:
            print("üìà IMPROVING - You're getting there!")
        else:
            print("üí™ LEARNING - Practice makes perfect!")
        
        input("\nPress Enter to continue...")
    
    def update_score(self, result: GameResult):
        """Update score based on game result with hint penalty"""
        self.total_games += 1
        if result.correct:
            base_points = 15
            time_bonus = max(0, int(10 - result.time_taken / 10))
            attempt_penalty = (result.attempts - 1) * 2
            hint_penalty = result.hints_used * 3
            
            points = max(1, base_points + time_bonus - attempt_penalty - hint_penalty)
            self.score += points
            print(f"\nüéØ SCORING BREAKDOWN:")
            print(f"   Base points: {base_points}")
            print(f"   Time bonus: +{time_bonus}")
            print(f"   Attempt penalty: -{attempt_penalty}")
            print(f"   Hint penalty: -{hint_penalty}")
            print(f"   Final score: {points} points!")
        else:
            print("‚ùå No points this time. Keep practicing!")
    
    def run(self):
        """Main game loop"""
        games = {
            "1": self.list_comprehension_challenge,
            "2": self.dictionary_challenge,
            "3": self.string_challenge,
            "4": self.function_challenge,
            "5": self.algorithm_challenge,
            "6": self.bug_hunt_challenge,
            "7": self.data_structure_challenge,
        }
        
        print("üöÄ Welcome to Python Be Good - Technical Edition!")
        print("Master Python through hands-on coding challenges!")
        print("üí° Pro tip: Type 'hint' during any challenge for help!")
        
        while True:
            self.clear_screen()
            self.print_banner()
            choice = self.show_menu()
            
            if choice == "q":
                print("\nüéì Thanks for practicing with Python Be Good!")
                print(f"Final Score: {self.score} | Games Played: {self.total_games}")
                if self.score > 100:
                    print("üèÜ Excellent coding skills demonstrated!")
                break
            elif choice == "8":
                self.set_difficulty()
            elif choice == "9":
                self.show_stats()
            elif choice in games:
                print(f"\nüî• Preparing technical challenge... Get ready to code!")
                time.sleep(2)
                result = games[choice]()
                self.update_score(result)
                input("\nPress Enter to continue...")
            
            time.sleep(1)

if __name__ == "__main__":
    game = PythonBeGood()
    try:
        game.run()
    except KeyboardInterrupt:
        print("\n\nGame interrupted. Thanks for coding!")
    except Exception as e:
        print(f"\nAn error occurred: {e}")
        print("Thanks for practicing!")
