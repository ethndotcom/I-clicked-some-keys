#!/usr/bin/env python3
"""
C Be Good - A game to practice C programming skills
Inspired by ThePrimeagen's vim-be-good
"""

import random
import time
import os
import sys
from typing import List, Dict, Any, Callable
from dataclasses import dataclass
from enum import Enum

class Difficulty(Enum):
    NOOB = "noob"
    EASY = "easy"
    MEDIUM = "medium"
    HARD = "hard"
    NIGHTMARE = "nightmare"

@dataclass
class GameResult:
    correct: bool
    time_taken: float
    attempts: int

class CBeGood:
    def __init__(self):
        self.score = 0
        self.total_games = 0
        self.difficulty = Difficulty.EASY
        
    def clear_screen(self):
        """Clear the terminal screen"""
        os.system('cls' if os.name == 'nt' else 'clear')
    
    def print_banner(self):
        """Print the game banner"""
        banner = """
â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—
â•‘              C BE GOOD                â•‘
â•‘      Practice C Programming          â•‘
â•‘        Master the Pointers!          â•‘
â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        """
        print(banner)
        print(f"Score: {self.score} | Games Played: {self.total_games} | Difficulty: {self.difficulty.value}")
        print("-" * 40)
    
    def show_menu(self) -> str:
        """Show main menu and get user choice"""
        options = {
            "1": "Pointer Arithmetic",
            "2": "Array Operations", 
            "3": "String Manipulation",
            "4": "Function Signatures",
            "5": "Memory Management",
            "6": "Struct Operations",
            "7": "C Syntax Quiz",
            "8": "Bug Hunt",
            "9": "Code Completion",
            "10": "Change Difficulty",
            "11": "View Stats",
            "q": "Quit"
        }
        
        print("\nChoose your challenge:")
        for key, value in options.items():
            print(f"{key:2}. {value}")
        
        while True:
            choice = input("\nEnter your choice: ").strip().lower()
            if choice in options:
                return choice
            print("Invalid choice! Please try again.")
    
    def set_difficulty(self):
        """Allow user to change difficulty"""
        print("\nSelect difficulty:")
        for i, diff in enumerate(Difficulty, 1):
            print(f"{i}. {diff.value.title()}")
        
        try:
            choice = int(input("Enter choice (1-5): "))
            if 1 <= choice <= 5:
                self.difficulty = list(Difficulty)[choice - 1]
                print(f"Difficulty set to: {self.difficulty.value}")
            else:
                print("Invalid choice!")
        except ValueError:
            print("Invalid input!")
        
        input("Press Enter to continue...")
    
    def get_time_limit(self) -> float:
        """Get time limit based on difficulty"""
        limits = {
            Difficulty.NOOB: 120.0,
            Difficulty.EASY: 60.0,
            Difficulty.MEDIUM: 30.0,
            Difficulty.HARD: 20.0,
            Difficulty.NIGHTMARE: 15.0
        }
        return limits[self.difficulty]
    
    def pointer_arithmetic_challenge(self) -> GameResult:
        """Challenge user with pointer arithmetic problems"""
        challenges = [
            {
                "description": "If int *p points to arr[2] and arr = {10, 20, 30, 40, 50}, what is *(p + 1)?",
                "explanation": "p points to arr[2] (30), so p+1 points to arr[3] (40)",
                "answer": "40",
                "options": ["30", "40", "50", "20"]
            },
            {
                "description": "Given: int arr[] = {1, 2, 3, 4}; int *p = arr; What does *(p++) return?",
                "explanation": "*(p++) returns current value (1) then increments p",
                "answer": "1",
                "options": ["1", "2", "0", "undefined"]
            },
            {
                "description": "If char *str = \"Hello\"; what is *(str + 1)?",
                "explanation": "str points to 'H', str+1 points to 'e'",
                "answer": "e",
                "options": ["H", "e", "l", "o"]
            },
            {
                "description": "What's the difference between ptr++ and ++ptr in terms of order?",
                "explanation": "ptr++ uses current value then increments, ++ptr increments then uses value",
                "answer": "ptr++ uses then increments, ++ptr increments then uses",
                "options": [
                    "ptr++ uses then increments, ++ptr increments then uses",
                    "Both are identical",
                    "ptr++ increments then uses, ++ptr uses then increments",
                    "No difference in C"
                ]
            }
        ]
        
        challenge = random.choice(challenges)
        print(f"\nPointer Arithmetic Challenge:")
        print(f"{challenge['description']}")
        
        if 'options' in challenge and len(challenge['options']) > 2:
            for i, option in enumerate(challenge['options'], 1):
                print(f"{i}. {option}")
            print("Enter the number of your choice:")
        
        attempts = 0
        start_time = time.time()
        time_limit = self.get_time_limit()
        
        while True:
            attempts += 1
            elapsed = time.time() - start_time
            remaining = time_limit - elapsed
            
            if remaining <= 0:
                print(f"\nTime's up!")
                print(f"Answer: {challenge['answer']}")
                print(f"Explanation: {challenge['explanation']}")
                return GameResult(False, elapsed, attempts)
            
            print(f"\nTime remaining: {remaining:.1f}s")
            user_input = input("Your answer: ").strip()
            
            # Handle numbered choices
            if 'options' in challenge and user_input.isdigit():
                choice_num = int(user_input) - 1
                if 0 <= choice_num < len(challenge['options']):
                    user_input = challenge['options'][choice_num]
            
            if user_input.lower() == challenge['answer'].lower():
                elapsed = time.time() - start_time
                print(f"\nCorrect! Time: {elapsed:.2f}s, Attempts: {attempts}")
                print(f"Explanation: {challenge['explanation']}")
                return GameResult(True, elapsed, attempts)
            else:
                print("Incorrect! Try again.")
    
    def array_operations_challenge(self) -> GameResult:
        """Challenge user with array operations"""
        challenges = [
            {
                "description": "Write the correct way to declare an array of 10 integers named 'numbers'",
                "answer": "int numbers[10];",
                "alternatives": ["int numbers[10]", "int numbers[10];", "int[10] numbers;"]
            },
            {
                "description": "How do you access the 5th element (index 4) of array 'arr'?",
                "answer": "arr[4]",
                "alternatives": ["arr[4]", "arr(4)", "arr.4", "*arr+4"]
            },
            {
                "description": "What's the size in bytes of: int matrix[3][4]; (assume int = 4 bytes)",
                "answer": "48",
                "alternatives": ["48", "12", "7", "16"],
                "explanation": "3 rows Ã— 4 columns Ã— 4 bytes = 48 bytes"
            },
            {
                "description": "Complete: int arr[] = {1,2,3}; int size = sizeof(arr)/sizeof(___);",
                "answer": "arr[0]",
                "alternatives": ["arr[0]", "int", "arr", "*arr"],
                "explanation": "sizeof(arr[0]) gives size of one element"
            }
        ]
        
        challenge = random.choice(challenges)
        print(f"\nArray Operations Challenge:")
        print(f"{challenge['description']}")
        
        attempts = 0
        start_time = time.time()
        time_limit = self.get_time_limit()
        
        while True:
            attempts += 1
            elapsed = time.time() - start_time
            remaining = time_limit - elapsed
            
            if remaining <= 0:
                print(f"\nTime's up! Answer: {challenge['answer']}")
                if 'explanation' in challenge:
                    print(f"Explanation: {challenge['explanation']}")
                return GameResult(False, elapsed, attempts)
            
            print(f"\nTime remaining: {remaining:.1f}s")
            user_input = input("Your answer: ").strip()
            
            # Check if answer matches any of the alternatives
            correct = any(user_input.lower().replace(" ", "") == alt.lower().replace(" ", "") 
                         for alt in challenge['alternatives'])
            
            if correct:
                elapsed = time.time() - start_time
                print(f"\nCorrect! Time: {elapsed:.2f}s, Attempts: {attempts}")
                if 'explanation' in challenge:
                    print(f"Explanation: {challenge['explanation']}")
                return GameResult(True, elapsed, attempts)
            else:
                print("Incorrect! Try again.")
    
    def string_manipulation_challenge(self) -> GameResult:
        """Challenge user with C string operations"""
        challenges = [
            {
                "description": "Which function is used to copy string 'src' to 'dest'?",
                "answer": "strcpy",
                "options": ["strcpy", "strcat", "strcmp", "strlen"]
            },
            {
                "description": "What does strlen(\"Hello\") return?",
                "answer": "5",
                "options": ["5", "6", "4", "undefined"],
                "explanation": "strlen counts characters excluding null terminator"
            },
            {
                "description": "How do you declare a string that can hold 50 characters?",
                "answer": "char str[51];",
                "alternatives": ["char str[51];", "char str[51]", "string str[50];"],
                "explanation": "Need extra space for null terminator"
            },
            {
                "description": "What's wrong with: char *str = \"Hello\"; str[0] = 'h';",
                "answer": "String literal is read-only",
                "options": [
                    "String literal is read-only",
                    "Need to use strcpy",
                    "Wrong syntax",
                    "Nothing wrong"
                ],
                "explanation": "String literals are stored in read-only memory"
            },
            {
                "description": "Complete this to concatenate: strcat(dest, ___);",
                "answer": "src",
                "alternatives": ["src", "source", "&src"],
                "explanation": "strcat(dest, src) appends src to dest"
            }
        ]
        
        challenge = random.choice(challenges)
        print(f"\nString Manipulation Challenge:")
        print(f"{challenge['description']}")
        
        if 'options' in challenge:
            for i, option in enumerate(challenge['options'], 1):
                print(f"{i}. {option}")
        
        attempts = 0
        start_time = time.time()
        time_limit = self.get_time_limit()
        
        while True:
            attempts += 1
            elapsed = time.time() - start_time
            remaining = time_limit - elapsed
            
            if remaining <= 0:
                print(f"\nTime's up! Answer: {challenge['answer']}")
                if 'explanation' in challenge:
                    print(f"Explanation: {challenge['explanation']}")
                return GameResult(False, elapsed, attempts)
            
            print(f"\nTime remaining: {remaining:.1f}s")
            user_input = input("Your answer: ").strip()
            
            # Handle numbered choices
            if 'options' in challenge and user_input.isdigit():
                choice_num = int(user_input) - 1
                if 0 <= choice_num < len(challenge['options']):
                    user_input = challenge['options'][choice_num]
            
            # Check alternatives if they exist
            if 'alternatives' in challenge:
                correct = any(user_input.lower().replace(" ", "") == alt.lower().replace(" ", "") 
                             for alt in challenge['alternatives'])
            else:
                correct = user_input.lower() == challenge['answer'].lower()
            
            if correct:
                elapsed = time.time() - start_time
                print(f"\nCorrect! Time: {elapsed:.2f}s, Attempts: {attempts}")
                if 'explanation' in challenge:
                    print(f"Explanation: {challenge['explanation']}")
                return GameResult(True, elapsed, attempts)
            else:
                print("Incorrect! Try again.")
    
    def function_signatures_challenge(self) -> GameResult:
        """Challenge user to write correct function signatures"""
        challenges = [
            {
                "description": "Write a function signature that takes two integers and returns their sum",
                "answer": "int add(int a, int b);",
                "alternatives": ["int add(int a, int b);", "int add(int a, int b)", "int add(int, int);"]
            },
            {
                "description": "Function that takes array of integers and its size, returns void",
                "answer": "void process(int arr[], int size);",
                "alternatives": [
                    "void process(int arr[], int size);",
                    "void process(int *arr, int size);",
                    "void process(int arr[], int size)"
                ]
            },
            {
                "description": "Function that returns pointer to integer",
                "answer": "int* getPointer();",
                "alternatives": ["int* getPointer();", "int *getPointer();", "int* getPointer()"]
            },
            {
                "description": "Function that takes pointer to pointer to char",
                "answer": "void func(char **ptr);",
                "alternatives": ["void func(char **ptr);", "void func(char **ptr)", "void func(char** ptr);"]
            },
            {
                "description": "Function that takes function pointer as parameter (function takes int, returns int)",
                "answer": "void caller(int (*func)(int));",
                "alternatives": ["void caller(int (*func)(int));", "void caller(int (*func)(int))"]
            }
        ]
        
        challenge = random.choice(challenges)
        print(f"\nFunction Signatures Challenge:")
        print(f"{challenge['description']}")
        print("Write the complete function signature (declaration):")
        
        attempts = 0
        start_time = time.time()
        time_limit = self.get_time_limit() * 1.5  # More time for function signatures
        
        while True:
            attempts += 1
            elapsed = time.time() - start_time
            remaining = time_limit - elapsed
            
            if remaining <= 0:
                print(f"\nTime's up! Answer: {challenge['answer']}")
                return GameResult(False, elapsed, attempts)
            
            print(f"\nTime remaining: {remaining:.1f}s")
            user_input = input("Your answer: ").strip()
            
            # Check if answer matches any of the alternatives (normalize spaces)
            normalized_input = ' '.join(user_input.split())
            correct = any(normalized_input.lower() == alt.lower() 
                         for alt in challenge['alternatives'])
            
            if correct:
                elapsed = time.time() - start_time
                print(f"\nCorrect! Time: {elapsed:.2f}s, Attempts: {attempts}")
                return GameResult(True, elapsed, attempts)
            else:
                print("Incorrect! Check your syntax and try again.")
    
    def memory_management_challenge(self) -> GameResult:
        """Challenge user with memory management concepts"""
        challenges = [
            {
                "description": "Which function is used to allocate memory dynamically?",
                "answer": "malloc",
                "options": ["malloc", "alloc", "new", "create"]
            },
            {
                "description": "What should you do after using malloc?",
                "answer": "Call free()",
                "options": ["Call free()", "Nothing", "Call delete", "Call close()"]
            },
            {
                "description": "How to allocate memory for 10 integers?",
                "answer": "malloc(10 * sizeof(int))",
                "alternatives": [
                    "malloc(10 * sizeof(int))",
                    "malloc(sizeof(int) * 10)",
                    "(int*)malloc(10 * sizeof(int))"
                ]
            },
            {
                "description": "What happens if you don't call free() after malloc()?",
                "answer": "Memory leak",
                "options": ["Memory leak", "Compile error", "Runtime error", "Nothing"],
                "explanation": "Memory remains allocated until program ends"
            },
            {
                "description": "Which is correct for allocating array of 5 doubles?",
                "answer": "double *arr = malloc(5 * sizeof(double));",
                "alternatives": [
                    "double *arr = malloc(5 * sizeof(double));",
                    "double *arr = (double*)malloc(5 * sizeof(double));",
                    "double *arr = malloc(sizeof(double) * 5);"
                ]
            },
            {
                "description": "What does calloc() do differently from malloc()?",
                "answer": "Initializes memory to zero",
                "options": [
                    "Initializes memory to zero",
                    "Allocates more memory",
                    "Is faster",
                    "No difference"
                ],
                "explanation": "calloc initializes allocated memory to zero"
            }
        ]
        
        challenge = random.choice(challenges)
        print(f"\nMemory Management Challenge:")
        print(f"{challenge['description']}")
        
        if 'options' in challenge:
            for i, option in enumerate(challenge['options'], 1):
                print(f"{i}. {option}")
        
        attempts = 0
        start_time = time.time()
        time_limit = self.get_time_limit()
        
        while True:
            attempts += 1
            elapsed = time.time() - start_time
            remaining = time_limit - elapsed
            
            if remaining <= 0:
                print(f"\nTime's up! Answer: {challenge['answer']}")
                if 'explanation' in challenge:
                    print(f"Explanation: {challenge['explanation']}")
                return GameResult(False, elapsed, attempts)
            
            print(f"\nTime remaining: {remaining:.1f}s")
            user_input = input("Your answer: ").strip()
            
            # Handle numbered choices
            if 'options' in challenge and user_input.isdigit():
                choice_num = int(user_input) - 1
                if 0 <= choice_num < len(challenge['options']):
                    user_input = challenge['options'][choice_num]
            
            # Check alternatives if they exist
            if 'alternatives' in challenge:
                correct = any(user_input.lower().replace(" ", "") == alt.lower().replace(" ", "") 
                             for alt in challenge['alternatives'])
            else:
                correct = user_input.lower() == challenge['answer'].lower()
            
            if correct:
                elapsed = time.time() - start_time
                print(f"\nCorrect! Time: {elapsed:.2f}s, Attempts: {attempts}")
                if 'explanation' in challenge:
                    print(f"Explanation: {challenge['explanation']}")
                return GameResult(True, elapsed, attempts)
            else:
                print("Incorrect! Try again.")
    
    def struct_operations_challenge(self) -> GameResult:
        """Challenge user with struct operations"""
        challenges = [
            {
                "description": "How do you access member 'age' of struct variable 'person'?",
                "answer": "person.age",
                "alternatives": ["person.age", "person->age (if pointer)", "person[age]"],
                "explanation": "Use . for struct variables, -> for struct pointers"
            },
            {
                "description": "How do you access member 'name' through struct pointer 'ptr'?",
                "answer": "ptr->name",
                "alternatives": ["ptr->name", "(*ptr).name"],
                "explanation": "Both ptr->name and (*ptr).name work"
            },
            {
                "description": "Complete the struct definition: struct Point { int x; ___ y; };",
                "answer": "int",
                "alternatives": ["int", "int y", "integer"],
                "explanation": "Need data type for member y"
            },
            {
                "description": "How to declare a struct Person variable named 'student'?",
                "answer": "struct Person student;",
                "alternatives": ["struct Person student;", "Person student;", "struct Person student"],
                "explanation": "Use 'struct' keyword unless typedef is used"
            },
            {
                "description": "What's sizeof(struct { char c; int i; }) likely to be? (int=4 bytes)",
                "answer": "8",
                "options": ["5", "8", "4", "6"],
                "explanation": "Padding added for alignment: char(1) + padding(3) + int(4) = 8"
            }
        ]
        
        challenge = random.choice(challenges)
        print(f"\nStruct Operations Challenge:")
        print(f"{challenge['description']}")
        
        if 'options' in challenge:
            for i, option in enumerate(challenge['options'], 1):
                print(f"{i}. {option}")
        
        attempts = 0
        start_time = time.time()
        time_limit = self.get_time_limit()
        
        while True:
            attempts += 1
            elapsed = time.time() - start_time
            remaining = time_limit - elapsed
            
            if remaining <= 0:
                print(f"\nTime's up! Answer: {challenge['answer']}")
                print(f"Explanation: {challenge['explanation']}")
                return GameResult(False, elapsed, attempts)
            
            print(f"\nTime remaining: {remaining:.1f}s")
            user_input = input("Your answer: ").strip()
            
            # Handle numbered choices
            if 'options' in challenge and user_input.isdigit():
                choice_num = int(user_input) - 1
                if 0 <= choice_num < len(challenge['options']):
                    user_input = challenge['options'][choice_num]
            
            # Check alternatives if they exist
            if 'alternatives' in challenge:
                correct = any(user_input.lower().replace(" ", "") == alt.lower().replace(" ", "") 
                             for alt in challenge['alternatives'])
            else:
                correct = user_input.lower() == challenge['answer'].lower()
            
            if correct:
                elapsed = time.time() - start_time
                print(f"\nCorrect! Time: {elapsed:.2f}s, Attempts: {attempts}")
                print(f"Explanation: {challenge['explanation']}")
                return GameResult(True, elapsed, attempts)
            else:
                print("Incorrect! Try again.")
    
    def c_syntax_quiz(self) -> GameResult:
        """Multiple choice quiz about C syntax and concepts"""
        questions = [
            {
                "question": "What's the correct way to include the standard I/O library?",
                "options": ["A) #include <stdio.h>", "B) include stdio.h", "C) #include stdio", "D) import stdio.h"],
                "answer": "A"
            },
            {
                "question": "Which operator is used for address-of?",
                "options": ["A) *", "B) &", "C) @", "D) #"],
                "answer": "B"
            },
            {
                "question": "What does the ++ operator do?",
                "options": ["A) Adds 2", "B) Increments by 1", "C) Multiplies by 2", "D) Nothing"],
                "answer": "B"
            },
            {
                "question": "Which is NOT a valid C data type?",
                "options": ["A) int", "B) float", "C) string", "D) char"],
                "answer": "C"
            },
            {
                "question": "What's the result of 5 % 2?",
                "options": ["A) 2.5", "B) 2", "C) 1", "D) 0"],
                "answer": "C"
            },
            {
                "question": "How do you declare a constant integer?",
                "options": ["A) const int x;", "B) final int x;", "C) static int x;", "D) readonly int x;"],
                "answer": "A"
            },
            {
                "question": "What does sizeof() return?",
                "options": ["A) Memory address", "B) Number of bytes", "C) Variable name", "D) Data type"],
                "answer": "B"
            }
        ]
        
        question = random.choice(questions)
        print(f"\nC Syntax Quiz:")
        print(f"Question: {question['question']}")
        for option in question['options']:
            print(option)
        
        attempts = 0
        start_time = time.time()
        time_limit = self.get_time_limit() / 2  # Quiz gets less time
        
        while True:
            attempts += 1
            elapsed = time.time() - start_time
            remaining = time_limit - elapsed
            
            if remaining <= 0:
                print(f"\nTime's up! The answer was: {question['answer']}")
                return GameResult(False, elapsed, attempts)
            
            print(f"\nTime remaining: {remaining:.1f}s")
            user_input = input("Your answer (A/B/C/D): ").strip().upper()
            
            if user_input == question['answer']:
                elapsed = time.time() - start_time
                print(f"\nCorrect! Time: {elapsed:.2f}s, Attempts: {attempts}")
                return GameResult(True, elapsed, attempts)
            elif user_input in ['A', 'B', 'C', 'D']:
                print("Incorrect! Try again.")
            else:
                print("Please enter A, B, C, or D")
    
    def bug_hunt_challenge(self) -> GameResult:
        """Find and fix bugs in C code"""
        bugs = [
            {
                "description": "Fix this printf statement",
                "buggy_code": "printf(\"Hello World\"",
                "fixed_code": "printf(\"Hello World\");",
                "explanation": "Missing closing parenthesis and semicolon"
            },
            {
                "description": "Fix this variable declaration",
                "buggy_code": "int x y = 5;",
                "fixed_code": "int x, y = 5;",
                "explanation": "Need comma between variable names"
            },
            {
                "description": "Fix this array access",
                "buggy_code": "int arr[5]; arr(0) = 10;",
                "fixed_code": "int arr[5]; arr[0] = 10;",
                "explanation": "Use square brackets, not parentheses for array access"
            },
            {
                "description": "Fix this pointer declaration",
                "buggy_code": "int ptr* = &x;",
                "fixed_code": "int *ptr = &x;",
                "explanation": "Asterisk should be before variable name"
            },
            {
                "description": "Fix this string comparison",
                "buggy_code": "if (str1 == str2)",
                "fixed_code": "if (strcmp(str1, str2) == 0)",
                "explanation": "Use strcmp() to compare strings, not == operator"
            },
            {
                "description": "Fix this loop condition",
                "buggy_code": "for (i = 0, i < 10, i++)",
                "fixed_code": "for (i = 0; i < 10; i++)",
                "explanation": "Use semicolons, not commas in for loop"
            }
        ]
        
        bug = random.choice(bugs)
        print(f"\nBug Hunt: {bug['description']}")
        print("Buggy code:")
        print(f"  {bug['buggy_code']}")
        print("\nWrite the fixed version:")
        
        attempts = 0
        start_time = time.time()
        time_limit = self.get_time_limit()
        
        while True:
            attempts += 1
            elapsed = time.time() - start_time
            remaining = time_limit - elapsed
            
            if remaining <= 0:
                print(f"\nTime's up!")
                print(f"Fixed code: {bug['fixed_code']}")
                print(f"Explanation: {bug['explanation']}")
                return GameResult(False, elapsed, attempts)
            
            print(f"\nTime remaining: {remaining:.1f}s")
            user_input = input("Your fixed code: ").strip()
            
            # Normalize spaces for comparison
            user_normalized = ' '.join(user_input.split())
            fixed_normalized = ' '.join(bug['fixed_code'].split())
            
            if user_normalized.lower() == fixed_normalized.lower():
                elapsed = time.time() - start_time
                print(f"\nCorrect! Time: {elapsed:.2f}s, Attempts: {attempts}")
                print(f"Explanation: {bug['explanation']}")
                return GameResult(True, elapsed, attempts)
            else:
                print("Not quite right. Try again!")
    
    def code_completion_challenge(self) -> GameResult:
        """Complete missing parts of C code"""
        challenges = [
            {
                "description": "Complete this main function",
                "code": "int main(___) {\n    return 0;\n}",
                "answer": "void",
                "alternatives": ["void", "", "int argc, char *argv[]"],
                "explanation": "main() can take void or argc/argv parameters"
            },
            {
                "description": "Complete this loop to print 0 to 4",
                "code": "for (int i = 0; ___; i++) {\n    printf(\"%d \", i);\n}",
                "answer": "i < 5",
                "alternatives": ["i < 5", "i <= 4"],
                "explanation": "Loop while i is less than 5"
            },
            {
                "description": "Complete this if condition to check if x is even",
                "code": "if (___) {\n    printf(\"Even\");\n}",
                "answer": "x % 2 == 0",
                "alternatives": ["x % 2 == 0", "(x % 2) == 0"],
                "explanation": "Modulo 2 equals 0 for even numbers"
            },
            {
                "description": "Complete this pointer dereference",
                "code": "int x = 5;\nint *ptr = &x;\nprintf(\"%d\", ___);\nint x = 5;\nint *ptr = &x;\nprintf(\"%d\", ___);" ,
                "answer": "*ptr",
                "alternatives": ["*ptr"],
                "explanation": "Use * to dereference pointer"
            }
        ]
        
        challenge = random.choice(challenges)
        print(f"\nCode Completion Challenge:")
        print(f"{challenge['description']}")
        print("\nCode:")
        print(challenge['code'])
        print(f"\nFill in the blank (___)")
        
        attempts = 0
        start_time = time.time()
        time_limit = self.get_time_limit()
        
        while True:
            attempts += 1
            elapsed = time.time() - start_time
            remaining = time_limit - elapsed
            
            if remaining <= 0:
                print(f"\nTime's up! Answer: {challenge['answer']}")
                print(f"Explanation: {challenge['explanation']}")
                return GameResult(False, elapsed, attempts)
            
            print(f"\nTime remaining: {remaining:.1f}s")
            user_input = input("Your answer: ").strip()
            
            # Check if answer matches any of the alternatives
            correct = any(user_input.lower().replace(" ", "") == alt.lower().replace(" ", "") 
                         for alt in challenge['alternatives'])
            
            if correct:
                elapsed = time.time() - start_time
                print(f"\nCorrect! Time: {elapsed:.2f}s, Attempts: {attempts}")
                print(f"Explanation: {challenge['explanation']}")
                return GameResult(True, elapsed, attempts)
            else:
                print("Incorrect! Try again.")
    
    def show_stats(self):
        """Show game statistics"""
        if self.total_games == 0:
            accuracy = 0
        else:
            accuracy = (self.score / self.total_games) * 100
        
        print(f"\n=== GAME STATISTICS ===")
        print(f"Total Score: {self.score}")
        print(f"Games Played: {self.total_games}")
        print(f"Accuracy: {accuracy:.1f}%")
        print(f"Current Difficulty: {self.difficulty.value}")
        
        # Fun C-related messages based on performance
        if accuracy >= 90:
            print("ðŸŽ‰ You're a C master! Dennis Ritchie would be proud!")
        elif accuracy >= 70:
            print("ðŸ’ª Solid C skills! Keep practicing those pointers!")
        elif accuracy >= 50:
            print("ðŸ“š Good progress! C is tricky but you're getting there!")
        else:
            print("ðŸ”§ Keep practicing! C takes time to master!")
        
        input("\nPress Enter to continue...")
    
    def update_score(self, result: GameResult):
        """Update score based on game result"""
        self.total_games += 1
        if result.correct:
            # Bonus points for speed and fewer attempts
            time_bonus = max(0, int(10 - result.time_taken))
            attempt_bonus = max(0, 5 - result.attempts)
            difficulty_bonus = list(Difficulty).index(self.difficulty)
            
            points = 10 + time_bonus + attempt_bonus + difficulty_bonus
            self.score += points
            print(f"You earned {points} points!")
            if time_bonus > 0:
                print(f"  Speed bonus: +{time_bonus}")
            if attempt_bonus > 0:
                print(f"  Accuracy bonus: +{attempt_bonus}")
            if difficulty_bonus > 0:
                print(f"  Difficulty bonus: +{difficulty_bonus}")
        else:
            print("No points this time. Keep practicing!")
    
    def run(self):
        """Main game loop"""
        games = {
            "1": self.pointer_arithmetic_challenge,
            "2": self.array_operations_challenge,
            "3": self.string_manipulation_challenge,
            "4": self.function_signatures_challenge,
            "5": self.memory_management_challenge,
            "6": self.struct_operations_challenge,
            "7": self.c_syntax_quiz,
            "8": self.bug_hunt_challenge,
            "9": self.code_completion_challenge,
        }
        
        print("Welcome to C Be Good!")
        print("Master the art of C programming!")
        print("From pointers to memory management - we've got it all!")
        
        while True:
            self.clear_screen()
            self.print_banner()
            choice = self.show_menu()
            
            if choice == "q":
                print("\nThanks for playing C Be Good!")
                print(f"Final Score: {self.score} | Games Played: {self.total_games}")
                print("Keep practicing those pointers! ðŸš€")
                break
            elif choice == "10":
                self.set_difficulty()
            elif choice == "11":
                self.show_stats()
            elif choice in games:
                print(f"\nStarting challenge... Prepare your brain! ðŸ§ ")
                time.sleep(2)
                result = games[choice]()
                self.update_score(result)
                input("\nPress Enter to continue...")
            
            time.sleep(1)

if __name__ == "__main__":
    game = CBeGood()
    try:
        game.run()
    except KeyboardInterrupt:
        print("\n\nGame interrupted. Thanks for playing C Be Good!")
    except Exception as e:
        print(f"\nAn error occurred: {e}")
        print("Thanks for playing!")