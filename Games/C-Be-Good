#!/usr/bin/env python3
"""
C Be Good - A technical game to practice C programming skills
Focused on actual code writing and deep C knowledge
Inspired by ThePrimeagen's vim-be-good
"""

import random
import time
import os
import sys
import re
from typing import List, Dict, Any, Callable
from dataclasses import dataclass
from enum import Enum

class Difficulty(Enum):
    NOOB = "noob"
    EASY = "easy"
    MEDIUM = "medium"
    HARD = "hard"
    NIGHTMARE = "nightmare"

@dataclass
class GameResult:
    correct: bool
    time_taken: float
    attempts: int
    hints_used: int

class CBeGood:
    def __init__(self):
        self.score = 0
        self.total_games = 0
        self.difficulty = Difficulty.EASY
        
    def clear_screen(self):
        """Clear the terminal screen"""
        os.system('cls' if os.name == 'nt' else 'clear')
    
    def print_banner(self):
        """Print the game banner"""
        banner = """
‚ïî‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïó
‚ïë              C BE GOOD                ‚ïë
‚ïë      Technical C Programming         ‚ïë
‚ïë        Write Real Code!              ‚ïë
‚ïö‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïù
        """
        print(banner)
        print(f"Score: {self.score} | Games Played: {self.total_games} | Difficulty: {self.difficulty.value}")
        print("-" * 40)
    
    def show_menu(self) -> str:
        """Show main menu and get user choice"""
        options = {
            "1": "Pointer Mastery",
            "2": "Array & Memory Operations", 
            "3": "String Implementation",
            "4": "Function & Callback Design",
            "5": "Dynamic Memory Challenges",
            "6": "Struct & Union Engineering",
            "7": "Preprocessor & Macros",
            "8": "Bit Manipulation",
            "9": "Systems Programming",
            "10": "Change Difficulty",
            "11": "View Stats",
            "q": "Quit"
        }
        
        print("\nChoose your technical challenge:")
        for key, value in options.items():
            print(f"{key:2}. {value}")
        
        while True:
            choice = input("\nEnter your choice: ").strip().lower()
            if choice in options:
                return choice
            print("Invalid choice! Please try again.")
    
    def set_difficulty(self):
        """Allow user to change difficulty"""
        print("\nSelect difficulty:")
        difficulties = {
            1: (Difficulty.NOOB, "Basic syntax and simple operations"),
            2: (Difficulty.EASY, "Standard C programming concepts"),
            3: (Difficulty.MEDIUM, "Advanced pointers and memory management"),
            4: (Difficulty.HARD, "Complex data structures and algorithms"),
            5: (Difficulty.NIGHTMARE, "Systems programming and optimizations")
        }
        
        for num, (diff, desc) in difficulties.items():
            print(f"{num}. {diff.value.title()}: {desc}")
        
        try:
            choice = int(input("Enter choice (1-5): "))
            if 1 <= choice <= 5:
                self.difficulty = difficulties[choice][0]
                print(f"Difficulty set to: {self.difficulty.value}")
            else:
                print("Invalid choice!")
        except ValueError:
            print("Invalid input!")
        
        input("Press Enter to continue...")
    
    def get_time_limit(self) -> float:
        """Get time limit based on difficulty"""
        limits = {
            Difficulty.NOOB: 300.0,      # 5 minutes
            Difficulty.EASY: 240.0,      # 4 minutes
            Difficulty.MEDIUM: 180.0,    # 3 minutes
            Difficulty.HARD: 120.0,      # 2 minutes
            Difficulty.NIGHTMARE: 90.0   # 1.5 minutes
        }
        return limits[self.difficulty]
    
    def show_hint(self, hints: List[str], hints_used: int) -> int:
        """Show progressive hints to the user"""
        if hints_used >= len(hints):
            print("üö´ No more hints available!")
            return hints_used
        
        print(f"\nüí° Hint {hints_used + 1}: {hints[hints_used]}")
        return hints_used + 1
    
    def normalize_code(self, code: str) -> str:
        """Normalize C code for comparison"""
        # Remove extra whitespace, normalize spacing around operators
        code = re.sub(r'\s+', ' ', code.strip())
        code = re.sub(r'\s*([{}();,*&\[\]])\s*', r'\1', code)
        code = re.sub(r'\s*([=+\-*/])\s*', r' \1 ', code)
        return code.lower()
    
    def check_code_similarity(self, user_code: str, expected_variants: List[str]) -> bool:
        """Check if user code matches any expected variant"""
        normalized_user = self.normalize_code(user_code)
        return any(normalized_user == self.normalize_code(variant) for variant in expected_variants)
    
    def pointer_mastery_challenge(self) -> GameResult:
        """Advanced pointer manipulation challenges"""
        challenges = {
            Difficulty.NOOB: [
                {
                    "description": """Write a function that swaps two integers using pointers.
Function signature: void swap(int *a, int *b)

Requirements:
- Use pointer dereferencing to swap values
- Function should modify the original variables""",
                    "expected_code": [
                        "void swap(int *a, int *b) { int temp = *a; *a = *b; *b = temp; }",
                        "void swap(int *a, int *b) { int t = *a; *a = *b; *b = t; }",
                        "void swap(int *a, int *b){int temp=*a;*a=*b;*b=temp;}"
                    ],
                    "hints": [
                        "You need a temporary variable to hold one value during the swap",
                        "Use *a to get the value that pointer a points to",
                        "Pattern: temp = *a; *a = *b; *b = temp;"
                    ]
                }
            ],
            Difficulty.EASY: [
                {
                    "description": """Write a function that reverses an array in-place using pointers.
Function signature: void reverse_array(int *arr, int size)

Requirements:
- Use two pointers (start and end)
- Swap elements from both ends moving inward
- Modify the original array""",
                    "expected_code": [
                        "void reverse_array(int *arr, int size) { int *start = arr; int *end = arr + size - 1; while (start < end) { int temp = *start; *start = *end; *end = temp; start++; end--; } }",
                        "void reverse_array(int *arr, int size){int *s=arr,*e=arr+size-1;while(s<e){int t=*s;*s=*e;*e=t;s++;e--;}}",
                        "void reverse_array(int *arr, int size) { for(int *l=arr, *r=arr+size-1; l<r; l++,r--) { int temp=*l; *l=*r; *r=temp; } }"
                    ],
                    "hints": [
                        "Initialize two pointers: start at arr, end at arr + size - 1",
                        "Use a while loop: while (start < end)",
                        "Swap *start and *end, then increment start and decrement end"
                    ]
                }
            ],
            Difficulty.MEDIUM: [
                {
                    "description": """Implement a function that rotates an array right by k positions using pointer arithmetic.
Function signature: void rotate_right(int *arr, int size, int k)

Requirements:
- Handle k > size cases (use modulo)
- Use only pointer arithmetic (no array indexing with [])
- Implement in-place rotation using reversal method
- Must use helper function to reverse subarrays""",
                    "expected_code": [
                        "void reverse_range(int *start, int *end) { while (start < end) { int temp = *start; *start = *end; *end = temp; start++; end--; } } void rotate_right(int *arr, int size, int k) { k = k % size; reverse_range(arr, arr + size - 1); reverse_range(arr, arr + k - 1); reverse_range(arr + k, arr + size - 1); }",
                    ],
                    "hints": [
                        "Use k = k % size to handle cases where k > size",
                        "Rotation can be done by: reverse entire array, reverse first k elements, reverse remaining elements",
                        "You'll need a helper function to reverse a range between two pointers",
                        "For right rotation by k: reverse all, reverse [0,k-1], reverse [k,size-1]"
                    ]
                }
            ],
            Difficulty.HARD: [
                {
                    "description": """Implement a function that finds the longest increasing subsequence in an array.
Function signature: int* longest_increasing_subsequence(int *arr, int size, int *result_size)

Requirements:
- Return dynamically allocated array containing the LIS
- Set *result_size to the length of the LIS
- Use dynamic programming approach
- Handle memory allocation properly""",
                    "expected_code": [
                        "int* longest_increasing_subsequence(int *arr, int size, int *result_size) { int *dp = malloc(size * sizeof(int)); int *prev = malloc(size * sizeof(int)); for(int i = 0; i < size; i++) { dp[i] = 1; prev[i] = -1; } int max_len = 1, max_idx = 0; for(int i = 1; i < size; i++) { for(int j = 0; j < i; j++) { if(arr[j] < arr[i] && dp[j] + 1 > dp[i]) { dp[i] = dp[j] + 1; prev[i] = j; } } if(dp[i] > max_len) { max_len = dp[i]; max_idx = i; } } *result_size = max_len; int *result = malloc(max_len * sizeof(int)); int idx = max_idx; for(int i = max_len - 1; i >= 0; i--) { result[i] = arr[idx]; idx = prev[idx]; } free(dp); free(prev); return result; }"
                    ],
                    "hints": [
                        "Use dynamic programming: dp[i] = length of LIS ending at index i",
                        "Keep track of previous indices to reconstruct the sequence",
                        "For each position, check all previous positions with smaller values",
                        "Don't forget to allocate memory for the result and free temporary arrays"
                    ]
                }
            ]
        }
        
        challenge_list = challenges.get(self.difficulty, challenges[Difficulty.EASY])
        challenge = random.choice(challenge_list)
        
        print(f"\n{'='*60}")
        print("üéØ POINTER MASTERY CHALLENGE")
        print(f"{'='*60}")
        print(f"\n{challenge['description']}")
        print(f"\nüìù Write your complete function below.")
        print("üí° Type 'hint' for a hint, 'quit' to give up")
        print("-" * 60)
        
        attempts = 0
        hints_used = 0
        start_time = time.time()
        time_limit = self.get_time_limit()
        
        while True:
            attempts += 1
            elapsed = time.time() - start_time
            remaining = time_limit - elapsed
            
            if remaining <= 0:
                print(f"\n‚è∞ Time's up!")
                print(f"‚úÖ Expected solution:")
                print(challenge['expected_code'][0])
                return GameResult(False, elapsed, attempts, hints_used)
            
            print(f"\n‚è±Ô∏è  Time remaining: {remaining:.1f}s | Attempt: {attempts}")
            user_input = input("Your code: ").strip()
            
            if user_input.lower() == 'quit':
                print("Giving up? Here's the solution:")
                print(challenge['expected_code'][0])
                return GameResult(False, time.time() - start_time, attempts, hints_used)
            
            if user_input.lower() == 'hint':
                hints_used = self.show_hint(challenge['hints'], hints_used)
                continue
            
            if self.check_code_similarity(user_input, challenge['expected_code']):
                elapsed = time.time() - start_time
                print(f"\nüéâ Excellent! Perfect solution!")
                print(f"‚è±Ô∏è  Time: {elapsed:.2f}s | Attempts: {attempts} | Hints: {hints_used}")
                return GameResult(True, elapsed, attempts, hints_used)
            else:
                print("‚ùå Not quite right. Check your syntax and logic.")
                if attempts >= 3:
                    print("üí° Struggling? Type 'hint' for help!")
    
    def array_memory_challenge(self) -> GameResult:
        """Advanced array and memory operation challenges"""
        challenges = {
            Difficulty.EASY: [
                {
                    "description": """Write a function that dynamically allocates a 2D integer array.
Function signature: int** create_2d_array(int rows, int cols)

Requirements:
- Allocate memory for array of int* pointers
- Allocate memory for each row
- Return pointer to array of pointers
- Handle allocation failures by returning NULL""",
                    "expected_code": [
                        "int** create_2d_array(int rows, int cols) { int **arr = malloc(rows * sizeof(int*)); if (!arr) return NULL; for (int i = 0; i < rows; i++) { arr[i] = malloc(cols * sizeof(int)); if (!arr[i]) { for (int j = 0; j < i; j++) free(arr[j]); free(arr); return NULL; } } return arr; }",
                        "int** create_2d_array(int rows, int cols){int **arr=malloc(rows*sizeof(int*));if(!arr)return NULL;for(int i=0;i<rows;i++){arr[i]=malloc(cols*sizeof(int));if(!arr[i]){for(int j=0;j<i;j++)free(arr[j]);free(arr);return NULL;}}return arr;}"
                    ],
                    "hints": [
                        "First allocate array of int* pointers using malloc(rows * sizeof(int*))",
                        "Then for each row, allocate memory for cols integers",
                        "Always check if malloc returns NULL",
                        "If any allocation fails, free previously allocated memory"
                    ]
                }
            ],
            Difficulty.MEDIUM: [
                {
                    "description": """Implement a dynamic array (vector) with resize capability.
Create a structure and functions for: creation, insertion, resizing, and cleanup.

Structure: typedef struct { int *data; int size; int capacity; } DynamicArray;
Functions needed:
- DynamicArray* create_array(int initial_capacity)
- void push_back(DynamicArray *arr, int value)  
- void cleanup_array(DynamicArray *arr)

Requirements:
- Double capacity when array is full
- Handle memory allocation failures""",
                    "expected_code": [
                        "typedef struct { int *data; int size; int capacity; } DynamicArray; DynamicArray* create_array(int initial_capacity) { DynamicArray *arr = malloc(sizeof(DynamicArray)); if (!arr) return NULL; arr->data = malloc(initial_capacity * sizeof(int)); if (!arr->data) { free(arr); return NULL; } arr->size = 0; arr->capacity = initial_capacity; return arr; } void push_back(DynamicArray *arr, int value) { if (arr->size >= arr->capacity) { int new_capacity = arr->capacity * 2; int *new_data = realloc(arr->data, new_capacity * sizeof(int)); if (!new_data) return; arr->data = new_data; arr->capacity = new_capacity; } arr->data[arr->size++] = value; } void cleanup_array(DynamicArray *arr) { if (arr) { free(arr->data); free(arr); } }"
                    ],
                    "hints": [
                        "The struct should track: data pointer, current size, and capacity",
                        "In push_back, check if size >= capacity, then resize using realloc",
                        "Double the capacity when resizing: new_capacity = capacity * 2",
                        "Always free both the data array and the struct in cleanup"
                    ]
                }
            ],
            Difficulty.HARD: [
                {
                    "description": """Implement a memory pool allocator for fixed-size blocks.
Structure: typedef struct { void *memory; void *free_list; int block_size; int num_blocks; } MemoryPool;

Functions:
- MemoryPool* create_pool(int block_size, int num_blocks)
- void* pool_alloc(MemoryPool *pool)
- void pool_free(MemoryPool *pool, void *ptr)
- void destroy_pool(MemoryPool *pool)

Requirements:
- Use a linked list of free blocks
- Each free block points to the next free block
- Return NULL when pool is exhausted""",
                    "expected_code": [
                        "typedef struct { void *memory; void *free_list; int block_size; int num_blocks; } MemoryPool; MemoryPool* create_pool(int block_size, int num_blocks) { MemoryPool *pool = malloc(sizeof(MemoryPool)); if (!pool) return NULL; pool->memory = malloc(block_size * num_blocks); if (!pool->memory) { free(pool); return NULL; } pool->block_size = block_size; pool->num_blocks = num_blocks; pool->free_list = pool->memory; char *ptr = (char*)pool->memory; for (int i = 0; i < num_blocks - 1; i++) { *(void**)(ptr + i * block_size) = ptr + (i + 1) * block_size; } *(void**)(ptr + (num_blocks - 1) * block_size) = NULL; return pool; } void* pool_alloc(MemoryPool *pool) { if (!pool->free_list) return NULL; void *block = pool->free_list; pool->free_list = *(void**)pool->free_list; return block; } void pool_free(MemoryPool *pool, void *ptr) { *(void**)ptr = pool->free_list; pool->free_list = ptr; } void destroy_pool(MemoryPool *pool) { if (pool) { free(pool->memory); free(pool); } }"
                    ],
                    "hints": [
                        "Initialize free list by linking all blocks together",
                        "Each block stores a pointer to the next free block in its first bytes",
                        "pool_alloc: take first block from free_list and update free_list",
                        "pool_free: add returned block to front of free_list"
                    ]
                }
            ]
        }
        
        challenge_list = challenges.get(self.difficulty, challenges[Difficulty.EASY])
        challenge = random.choice(challenge_list)
        
        print(f"\n{'='*60}")
        print("üß† ARRAY & MEMORY OPERATIONS CHALLENGE")
        print(f"{'='*60}")
        print(f"\n{challenge['description']}")
        print(f"\nüìù Write your complete implementation below.")
        print("üí° Type 'hint' for a hint, 'quit' to give up")
        print("-" * 60)
        
        attempts = 0
        hints_used = 0
        start_time = time.time()
        time_limit = self.get_time_limit()
        
        while True:
            attempts += 1
            elapsed = time.time() - start_time
            remaining = time_limit - elapsed
            
            if remaining <= 0:
                print(f"\n‚è∞ Time's up!")
                print(f"‚úÖ Expected solution:")
                print(challenge['expected_code'][0])
                return GameResult(False, elapsed, attempts, hints_used)
            
            print(f"\n‚è±Ô∏è  Time remaining: {remaining:.1f}s | Attempt: {attempts}")
            user_input = input("Your code: ").strip()
            
            if user_input.lower() == 'quit':
                print("Giving up? Here's the solution:")
                print(challenge['expected_code'][0])
                return GameResult(False, time.time() - start_time, attempts, hints_used)
            
            if user_input.lower() == 'hint':
                hints_used = self.show_hint(challenge['hints'], hints_used)
                continue
            
            if self.check_code_similarity(user_input, challenge['expected_code']):
                elapsed = time.time() - start_time
                print(f"\nüéâ Outstanding! Perfect memory management!")
                print(f"‚è±Ô∏è  Time: {elapsed:.2f}s | Attempts: {attempts} | Hints: {hints_used}")
                return GameResult(True, elapsed, attempts, hints_used)
            else:
                print("‚ùå Not quite right. Check your memory allocation and logic.")
                if attempts >= 3:
                    print("üí° Struggling? Type 'hint' for help!")
    
    def string_implementation_challenge(self) -> GameResult:
        """Implement string functions from scratch"""
        challenges = {
            Difficulty.EASY: [
                {
                    "description": """Implement your own strlen function.
Function signature: int my_strlen(const char *str)

Requirements:
- Count characters until null terminator
- Do not use any standard library functions
- Return the length of the string""",
                    "expected_code": [
                        "int my_strlen(const char *str) { int len = 0; while (str[len] != '\\0') len++; return len; }",
                        "int my_strlen(const char *str) { int len = 0; while (*str++) len++; return len; }",
                        "int my_strlen(const char *str){int len=0;while(str[len])len++;return len;}"
                    ],
                    "hints": [
                        "Start with a counter at 0",
                        "Loop until you find the null terminator ('\\0')",
                        "Increment counter for each character",
                        "You can use str[len] or *(str + len) to access characters"
                    ]
                }
            ],
            Difficulty.MEDIUM: [
                {
                    "description": """Implement a function that removes all occurrences of a character from a string in-place.
Function signature: void remove_char(char *str, char ch)

Requirements:
- Modify the string in-place (don't allocate new memory)
- Remove all occurrences of the specified character
- Maintain the order of remaining characters
- Properly null-terminate the result""",
                    "expected_code": [
                        "void remove_char(char *str, char ch) { int write_pos = 0; for (int read_pos = 0; str[read_pos] != '\\0'; read_pos++) { if (str[read_pos] != ch) { str[write_pos++] = str[read_pos]; } } str[write_pos] = '\\0'; }",
                        "void remove_char(char *str, char ch){int w=0;for(int r=0;str[r];r++){if(str[r]!=ch)str[w++]=str[r];}str[w]='\\0';}"
                    ],
                    "hints": [
                        "Use two pointers: one for reading, one for writing",
                        "Copy characters that don't match the target character",
                        "Only advance write pointer when copying a character",
                        "Don't forget to null-terminate at the end"
                    ]
                }
            ],
            Difficulty.HARD: [
                {
                    "description": """Implement a function that finds the longest common subsequence of two strings.
Function signature: char* longest_common_subsequence(const char *str1, const char *str2)

Requirements:
- Return dynamically allocated string containing the LCS
- Use dynamic programming approach
- Handle empty strings and no common subsequence cases
- Free any temporary memory used""",
                    "expected_code": [
                        "char* longest_common_subsequence(const char *str1, const char *str2) { int len1 = strlen(str1), len2 = strlen(str2); int **dp = malloc((len1+1) * sizeof(int*)); for(int i = 0; i <= len1; i++) dp[i] = calloc(len2+1, sizeof(int)); for(int i = 1; i <= len1; i++) { for(int j = 1; j <= len2; j++) { if(str1[i-1] == str2[j-1]) dp[i][j] = dp[i-1][j-1] + 1; else dp[i][j] = (dp[i-1][j] > dp[i][j-1]) ? dp[i-1][j] : dp[i][j-1]; } } int lcs_len = dp[len1][len2]; char *result = malloc(lcs_len + 1); result[lcs_len] = '\\0'; int i = len1, j = len2, k = lcs_len - 1; while(i > 0 && j > 0) { if(str1[i-1] == str2[j-1]) { result[k--] = str1[i-1]; i--; j--; } else if(dp[i-1][j] > dp[i][j-1]) i--; else j--; } for(int x = 0; x <= len1; x++) free(dp[x]); free(dp); return result; }"
                    ],
                    "hints": [
                        "Create a 2D DP table: dp[i][j] = LCS length of str1[0..i-1] and str2[0..j-1]",
                        "If characters match: dp[i][j] = dp[i-1][j-1] + 1",
                        "If they don't match: dp[i][j] = max(dp[i-1][j], dp[i][j-1])",
                        "Backtrack from dp[len1][len2] to construct the actual LCS string"
                    ]
                }
            ]
        }
        
        challenge_list = challenges.get(self.difficulty, challenges[Difficulty.EASY])
        challenge = random.choice(challenge_list)
        
        print(f"\n{'='*60}")
        print("üìù STRING IMPLEMENTATION CHALLENGE")
        print(f"{'='*60}")
        print(f"\n{challenge['description']}")
        print(f"\nüìù Write your complete function below.")
        print("üí° Type 'hint' for a hint, 'quit' to give up")
        print("-" * 60)
        
        attempts = 0
        hints_used = 0
        start_time = time.time()
        time_limit = self.get_time_limit()
        
        while True:
            attempts += 1
            elapsed = time.time() - start_time
            remaining = time_limit - elapsed
            
            if remaining <= 0:
                print(f"\n‚è∞ Time's up!")
                print(f"‚úÖ Expected solution:")
                print(challenge['expected_code'][0])
                return GameResult(False, elapsed, attempts, hints_used)
            
            print(f"\n‚è±Ô∏è  Time remaining: {remaining:.1f}s | Attempt: {attempts}")
            user_input = input("Your code: ").strip()
            
            if user_input.lower() == 'quit':
                print("Giving up? Here's the solution:")
                print(challenge['expected_code'][0])
                return GameResult(False, time.time() - start_time, attempts, hints_used)
            
            if user_input.lower() == 'hint':
                hints_used = self.show_hint(challenge['hints'], hints_used)
                continue
            
            if self.check_code_similarity(user_input, challenge['expected_code']):
                elapsed = time.time() - start_time
                print(f"\nüéâ Brilliant! String manipulation master!")
                print(f"‚è±Ô∏è  Time: {elapsed:.2f}s | Attempts: {attempts} | Hints: {hints_used}")
                return GameResult(True, elapsed, attempts, hints_used)
            else:
                print("‚ùå Not quite right. Check your string handling logic.")
                if attempts >= 3:
                    print("üí° Struggling? Type 'hint' for help!")
    
    def function_callback_challenge(self) -> GameResult:
        """Advanced function and callback challenges"""
        challenges = {
            Difficulty.MEDIUM: [
                {
                    "description": """Implement a generic map function that applies a function to each element of an array.
Function signature: void map_array(int *arr, int size, int (*func)(int))

Requirements:
- Apply the function to each element in-place
- The function pointer takes an int and returns an int
- Modify the original array

Also implement a sample function: int double_value(int x) that doubles the input.""",
                    "expected_code": [
                        "int double_value(int x) { return x * 2; } void map_array(int *arr, int size, int (*func)(int)) { for (int i = 0; i < size; i++) { arr[i] = func(arr[i]); } }",
                        "int double_value(int x){return x*2;}void map_array(int *arr, int size, int (*func)(int)){for(int i=0;i<size;i++)arr[i]=func(arr[i]);}"
                    ],
                    "hints": [
                        "The function pointer syntax is: int (*func)(int)",
                        "Call the function pointer like a normal function: func(arr[i])",
                        "Loop through the array and apply the function to each element",
                        "Store the result back in the same array position"
                    ]
                }
            ],
            Difficulty.HARD: [
                {
                    "description": """Implement a function that sorts an array using a custom comparison function.
Function signature: void generic_sort(void *arr, int size, int elem_size, int (*compare)(const void*, const void*))

Requirements:
- Implement bubble sort algorithm
- Work with void pointers for generic data
- Use the comparison function to determine order
- Swap elements using memcpy or similar

Also implement: int int_compare(const void *a, const void *b) for comparing integers.""",
                    "expected_code": [
                        "int int_compare(const void *a, const void *b) { int ia = *(const int*)a; int ib = *(const int*)b; return (ia > ib) - (ia < ib); } void generic_sort(void *arr, int size, int elem_size, int (*compare)(const void*, const void*)) { char *base = (char*)arr; for (int i = 0; i < size - 1; i++) { for (int j = 0; j < size - i - 1; j++) { if (compare(base + j * elem_size, base + (j + 1) * elem_size) > 0) { char temp[elem_size]; memcpy(temp, base + j * elem_size, elem_size); memcpy(base + j * elem_size, base + (j + 1) * elem_size, elem_size); memcpy(base + (j + 1) * elem_size, temp, elem_size); } } } }"
                    ],
                    "hints": [
                        "Cast void* to char* to do pointer arithmetic",
                        "Each element is at position: base + i * elem_size",
                        "Use memcpy to swap elements safely",
                        "The compare function returns: <0 if a<b, 0 if a==b, >0 if a>b"
                    ]
                }
            ]
        }
        
        challenge_list = challenges.get(self.difficulty, challenges[Difficulty.MEDIUM])
        challenge = random.choice(challenge_list)
        
        print(f"\n{'='*60}")
        print("üîß FUNCTION & CALLBACK DESIGN CHALLENGE")
        print(f"{'='*60}")
        print(f"\n{challenge['description']}")
        print(f"\nüìù Write your complete implementation below.")
        print("üí° Type 'hint' for a hint, 'quit' to give up")
        print("-" * 60)
        
        attempts = 0
        hints_used = 0
        start_time = time.time()
        time_limit = self.get_time_limit()
        
        while True:
            attempts += 1
            elapsed = time.time() - start_time
            remaining = time_limit - elapsed
            
            if remaining <= 0:
                print(f"\n‚è∞ Time's up!")
                print(f"‚úÖ Expected solution:")
                print(challenge['expected_code'][0])
                return GameResult(False, elapsed, attempts, hints_used)
            
            print(f"\n‚è±Ô∏è  Time remaining: {remaining:.1f}s | Attempt: {attempts}")
            user_input = input("Your code: ").strip()
            
            if user_input.lower() == 'quit':
                print("Giving up? Here's the solution:")
                print(challenge['expected_code'][0])
                return GameResult(False, time.time() - start_time, attempts, hints_used)
            
            if user_input.lower() == 'hint':
                hints_used = self.show_hint(challenge['hints'], hints_used)
                continue
            
            if self.check_code_similarity(user_input, challenge['expected_code']):
                elapsed = time.time() - start_time
                print(f"\nüéâ Exceptional! Function pointer mastery!")
                print(f"‚è±Ô∏è  Time: {elapsed:.2f}s | Attempts: {attempts} | Hints: {hints_used}")
                return GameResult(True, elapsed, attempts, hints_used)
            else:
                print("‚ùå Not quite right. Check your function pointer syntax and logic.")
                if attempts >= 3:
                    print("üí° Struggling? Type 'hint' for help!")

    def show_stats(self):
        """Show detailed game statistics"""
        if self.total_games == 0:
            accuracy = 0
        else:
            accuracy = (self.score / (self.total_games * 100)) * 100  # Assuming max 100 points per game
        
        print(f"\n{'='*50}")
        print("üìä TECHNICAL PROGRAMMING STATISTICS")
        print(f"{'='*50}")
        print(f"üèÜ Total Score: {self.score}")
        print(f"üéÆ Games Played: {self.total_games}")
        print(f"üéØ Success Rate: {accuracy:.1f}%")
        print(f"‚öôÔ∏è  Current Difficulty: {self.difficulty.value.upper()}")
        
        # Performance-based messages
        if accuracy >= 90:
            print("\nüî• LEGENDARY C PROGRAMMER!")
            print("   You're writing code like Linus Torvalds!")
        elif accuracy >= 75:
            print("\nüí™ ADVANCED C DEVELOPER!")
            print("   Your pointer skills are getting dangerous!")
        elif accuracy >= 60:
            print("\nüìà SOLID PROGRESS!")
            print("   You're mastering the dark arts of C!")
        elif accuracy >= 40:
            print("\nüéØ KEEP PRACTICING!")
            print("   Every segfault brings you closer to enlightenment!")
        else:
            print("\nüîß DEBUGGING MODE ACTIVATED!")
            print("   Rome wasn't built in a day, neither was the Linux kernel!")
        
        print(f"\n{'='*50}")
        input("Press Enter to continue your C mastery journey...")
    
    def update_score(self, result: GameResult):
        """Update score based on game result with detailed scoring"""
        self.total_games += 1
        if result.correct:
            # Base points
            base_points = 50
            
            # Time bonus (faster = more points)
            time_bonus = max(0, int(30 - result.time_taken))
            
            # Attempt bonus (fewer attempts = more points)
            attempt_bonus = max(0, (5 - result.attempts) * 5)
            
            # Hint penalty (fewer hints = more points)
            hint_penalty = result.hints_used * 5
            
            # Difficulty multiplier
            difficulty_multiplier = {
                Difficulty.NOOB: 1.0,
                Difficulty.EASY: 1.2,
                Difficulty.MEDIUM: 1.5,
                Difficulty.HARD: 2.0,
                Difficulty.NIGHTMARE: 2.5
            }[self.difficulty]
            
            total_points = int((base_points + time_bonus + attempt_bonus - hint_penalty) * difficulty_multiplier)
            total_points = max(10, total_points)  # Minimum 10 points
            
            self.score += total_points
            
            print(f"\nüéØ SCORING BREAKDOWN:")
            print(f"   Base points: {base_points}")
            if time_bonus > 0:
                print(f"   Speed bonus: +{time_bonus}")
            if attempt_bonus > 0:
                print(f"   Accuracy bonus: +{attempt_bonus}")
            if hint_penalty > 0:
                print(f"   Hint penalty: -{hint_penalty}")
            print(f"   Difficulty multiplier: x{difficulty_multiplier}")
            print(f"   üèÜ Total earned: {total_points} points!")
        else:
            print("\nüíÄ No points this time. Real programmers learn from their mistakes!")
    
    def run(self):
        """Main game loop"""
        games = {
            "1": self.pointer_mastery_challenge,
            "2": self.array_memory_challenge,
            "3": self.string_implementation_challenge,
            "4": self.function_callback_challenge,
            # Placeholder for additional challenges
            "5": self.array_memory_challenge,  # Reuse for now
            "6": self.string_implementation_challenge,  # Reuse for now
            "7": self.function_callback_challenge,  # Reuse for now
            "8": self.pointer_mastery_challenge,  # Reuse for now
            "9": self.array_memory_challenge,  # Reuse for now
        }
        
        print("üöÄ Welcome to C Be Good - Technical Edition!")
        print("üíª Where real programmers come to sharpen their skills!")
        print("‚ö° Write actual C code to solve challenging problems!")
        print("üß† From pointers to memory management - code your way to mastery!")
        
        while True:
            self.clear_screen()
            self.print_banner()
            choice = self.show_menu()
            
            if choice == "q":
                print(f"\nüéØ Thanks for coding with C Be Good!")
                print(f"üìä Final Score: {self.score} | Games Completed: {self.total_games}")
                if self.total_games > 0:
                    avg_score = self.score / self.total_games
                    print(f"üìà Average Score: {avg_score:.1f} points per challenge")
                print("üî• Keep practicing, and may your pointers always point true! üî•")
                break
            elif choice == "10":
                self.set_difficulty()
            elif choice == "11":
                self.show_stats()
            elif choice in games:
                print(f"\nüéØ Loading technical challenge...")
                print(f"üí° Remember: Type 'hint' for help, 'quit' to give up")
                print(f"‚ö° Challenge difficulty: {self.difficulty.value.upper()}")
                time.sleep(2)
                result = games[choice]()
                self.update_score(result)
                input("\nüöÄ Press Enter to continue your programming journey...")
            
            time.sleep(1)

if __name__ == "__main__":
    game = CBeGood()
    try:
        game.run()
    except KeyboardInterrupt:
        print("\n\nüíª Challenge interrupted! Come back when you're ready to code!")
    except Exception as e:
        print(f"\n‚ùå Runtime error occurred: {e}")
        print("üîß Even the best programmers encounter bugs. Try again!")
